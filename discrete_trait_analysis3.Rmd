---
title: "discrete_trait_analysis.rmd"
author: "Hanley"
date: "`r Sys.Date()`"
output:
  html_document: 
    toc: yes
editor_options: 
  chunk_output_type: inline
---

#! /usr/bin/env Rscript

```{r setup, message = FALSE}

library(knitr)
library(kableExtra)
library(grid)
library(diagram)

library(table1)
library(dplyr)
library(tidyr)


library(ggplot2)
library(ggpubr)
library(magrittr)
library(ggtree)
library(phangorn)

library(seqinr)

# Set file paths - if knitting, save in a folder by date
if (knitr::is_html_output()) {
  new_dir <- paste0("../results/regional trends/", format(Sys.Date(), "%b%d_%Y"), "/")
  dir.create(paste0(new_dir, "examples/"), recursive = TRUE)
  dir.create(paste0(new_dir, "A1/"), recursive = TRUE)
  dir.create(paste0(new_dir, "C/"), recursive = TRUE)
  dir.create(paste0(new_dir, "D/"), recursive = TRUE)
  save_path <- new_dir
} else {
  save_path <- "../results/regional trends/"
}

#Create subtype and example folders if they don't exist
if(!dir.exists(paste0(save_path, "examples"))){dir.create(paste0(save_path, "examples"))}
if(!dir.exists(paste0(save_path, "raw_results"))){dir.create(paste0(save_path, "raw_results"))}
if(!dir.exists(paste0(save_path, "A1"))){dir.create(paste0(save_path, "A1"))}
if(!dir.exists(paste0(save_path, "C"))){dir.create(paste0(save_path, "C"))}
if(!dir.exists(paste0(save_path, "D"))){dir.create(paste0(save_path, "D"))}

print(paste0("Results saved to: ", save_path))


```

### Script parameters (which chunks run, when)
```{r}
# Indicate whether to write permutation plots (ie. whether to evaluate code for permutation plots): This is default set to FALSE because this is very computationally expensive 
write_perms <- FALSE

# Indicate whether to remove objects between runs (this is recommended and probably necessary to run the whole script with the recommended constants for parsimony, permutations, and sub-samples). By default, this is set to true when knitting and false otherwise
drop_ASR <- ifelse(knitr::is_html_output(), TRUE, FALSE) #This needs to be true when knitting the whole doc, otherwise will run out of space

# Specify which subtypes to run
A1 <- TRUE
C <- TRUE
D <- TRUE

# Specify which trees to run (1=PWID SHARP-only region, 2=region, 3=risk, 4=risk & PWID combined, 5=risk, only among PWID cluster tree - I didn't end up using)
run1 <- TRUE
run2 <- TRUE
run3 <- TRUE
run4 <- TRUE
run5 <- FALSE

#specif whether to run proportionate subsampling chunks (these tend to take longer)
run_propotionate <- TRUE #I suggest setting to FALSE, as some of the larger proportionate subsampling trees run out of computational space
save_backup <- TRUE #Whether to save backupos of the unsumarrized transition count data (note: this doesn't save all raw data, just the rawer form of the summary data)


cat("Subtypes run: ", names(which(c("A1"=A1, "C"=C, "D"=D))),
    "\nASR run: ", paste(names(which(c("SHARP region"=run1, "All region"=run2,
                                 "Key pops (risk)"=run3, "PWID (vs not-PWID) & Region combined"=run4,
                                 "PWID-containing clusters (not using in paper"=run5))), ";"),
    "\nRun proportionate subsampling trees (note: SHARP one will run regardless because small): ",
    run_propotionate,
    "\nSave permutation plots (computationally expensive): ", write_perms,
    "\nRemove ASR objects between ASR runs (and between subtypes) to save space: ", drop_ASR)
```



# Set constants  
use small numbers for troubleshooting (suggested: 5, 20, 3, 3, 3, 3) and large numbers (suggested: 15, 200, 10, 20, 30, 30) for actual trials  
For troubleshooting and QC checks: set n_parsimony and n_subsamples to 1 and confirm that within Nairobi an Coast_to_Nairobi leaf counts sum to total number of Nairobi leaves
```{r}
n_parsimony <- 20 #number of replicates to perform for randomly resolving parsimony / ASR likelihoods (note: this is slightly misnamed. It is really N resolutions of ASR likelihoods)
n_permutations <- 200 #number of times to resample trait values for permutations

n_subsamples_A1 <- 10 #number of subsampled trees included (this in only used when making the summary table and MUST match n_subsamples from discrete_trait_analysis get_subsamples)
n_subsamples_A1.prop <- 20 #proportionate subsampling results in very small sample sizes for some traits, therefore, larger subsamples are necessary for inference (may not have space for 30!)
n_subsamples_C <- 30 #I suggest allowing for more subsamples for the C and D trees 
n_subsamples_D <- 30


cat(
  "N parsimony (number of replicates):", n_parsimony,
  "\nN permutations (number of resamplings for developing null distribution):", n_permutations,
  "\nN subsampled trees (A1 substype - no subsampling & uniform subsampling):", n_subsamples_A1,
  "\nN subsampled trees (A1 substype - proportionate subsampling):", n_subsamples_A1.prop,
  "\nN subsampled trees (C substype):", n_subsamples_C,
  "\nN subsampled trees (D substype):", n_subsamples_D
)
```



# Read in data
### Metadata
```{r read in metadata}
# SHARP only
tree.SHARP_hiv.meta <- readRDS("../HIV/meta_tree.SHARP_hiv.A1.rds") %>% #metadata
  select(-c(parent, node, branch.length)) # drop info about tree to avoid errors

#Get vector of all SHARP seq names
data.SHARP_hiv <- readRDS("../metadata/participants.SHARP_hiv.rds") 
SHARP_seq_names <- data.SHARP_hiv$annotated_name
rm(data.SHARP_hiv)

# SHARP and published
tree.hiv.meta <- readRDS("../HIV/meta_tree.hiv.CN.A1.rds") %>% #metadata
  select(-c(parent, node, branch.length)) # drop info about tree to avoid errors

```


IMPORTANT: The metadata contains tree info ("parent", "node", "branch.length"), but this info is NOT used in any of the ASR, as it would not appropriately refer to the locations in the subsetted trees. To avoid errors, I have dropped these columns. Therefore, the "tree." prefix before the metadata is incorrect. This is simply a data frame and can be linked to tree data ONLY via matching labels / ids.  


### tree data
```{r A1 - read in tree data}
# SHARP only
tree.SHARP_hiv <- readRDS("../HIV/tree.SHARP_hiv.A1.rds") #tree data object

# SHARP and published
tree.hiv <- readRDS("../HIV/tree.hiv.CN.A1.rds") #tree data object
```  

### sequence subsets
```{r A1 - read in seq lists}
# Single
Uniform_region_SHARP.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_region_SHARP.A1.seqs.rds")
Uniform_region.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_region.A1.seqs.rds")
Uniform_risk.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_risk.A1.seqs.rds")
Uniform_regionrisk.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_regionrisk.A1.seqs.rds")
Proportionate_SHARP.seqs <- readRDS("../HIV/subsampled_seq_lists/Proportionate_region_SHARP.A1.seqs.rds")
Proportionate_regionrisk.seqs <- readRDS("../HIV/subsampled_seq_lists/Proportionate_regionrisk.A1.seqs.rds")
Proportionate_regionrisk2.seqs <- readRDS("../HIV/subsampled_seq_lists/Proportionate_regionrisk2.A1.seqs.rds")

#Other subsets
non_missing_risk_CN.seqs.list <- tree.hiv.meta %>%
  filter(!is.na(risk3.F) & !is.na(region.CN) &
           label %in% tree.hiv$tip.label) %>% pull(label) #all seqs from Coast or Nairobi with an available risk value
PWID_cluster.seqs <- read.fasta("../HIV/GeneiousandIQtree/SHARP_and_published/A1/hiv_SHARP_and_published_A1_annotated_names.PWID_clust.fasta") %>% names()
 # PWID cluster tree (read in seqnames in PWID clusters then extract from larger tree)


# Lists
Uniform_region_SHARP.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_region_SHARP.A1.seqs.list.rds")
Uniform_region.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_region.A1.seqs.list.rds")
Uniform_risk.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_risk.A1.seqs.list.rds")
Uniform_regionrisk.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_regionrisk.A1.seqs.list.rds")
Proportionate_region_SHARP.seqs.list <- readRDS("../HIV/subsampled_seq_lists/proportionate_region_SHARP.A1.seqs.list.rds")
Proportionate_SHARP.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Proportionate_region_SHARP.A1.seqs.list.rds")
Proportionate_regionrisk.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Proportionate_regionrisk.A1.seqs.list.rds")
Proportionate_regionrisk2.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Proportionate_regionrisk2.A1.seqs.list.rds")

```


Note: C and D subtype data are read-in in respective ASR sections  
  


### Read in the population size percentages  
For scaling counts by pop size in flow diagram (note: didn't end up using this)
```{r read in the population size percentages}
region_risk_comb_pop_sizes <- readRDS("../HIV/pop_size_counts/region_risk_comb_pop_sizes.rds")
```

  
  

### check if trees are binary (bifurcating) and rooted  
ALL trees must be bifurcating
WARNING: If a tree is not rooted, the ASR steps must account for that (because there will be 1 fewer internal node - luckily, this should cause an error, so it shouldn't be possible to run ASR without accounting for unrooted trees)
```{r check binary and bifurcating}
is.binary.phylo(tree.SHARP_hiv)
is.rooted.phylo(tree.SHARP_hiv) #Not rooted!

is.binary.phylo(tree.hiv)
is.rooted.phylo(tree.hiv)
```

TO DO: I want to root the SHARP tree, so the phylogeny look pretty; however, this will require re-selecting an the example clade and reduing a number of checks, so may not end up doing


<br><br><br>


## EXAMPLE SUBTREE: Extract a clade from the tree - to test and visualize functions

#### SHARP only
```{r extract subtree - SHARP}
tree.SHARP_hiv.sub <- extract.clade(tree.SHARP_hiv, 240)

# Tree structure
str(tree.SHARP_hiv.sub)
```

```{r extract subtree - SHARP 2, fig.width=12, fig.height=8}
is.binary.phylo(tree.SHARP_hiv.sub)

#With tip labels
plot(tree.SHARP_hiv.sub, main = "SHARP - example subtree")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(0, -0.3)) 
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(0, -0.3))
edgelabels(col = "blue", frame = "none")

#Without tip labels
plot(tree.SHARP_hiv.sub, show.tip.label = FALSE, main = "SHARP - example subtree")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(0, -0.3)) #export as PDF to zoom in
edgelabels(col = "blue", frame = "none")

# check region distribution
table(tree.SHARP_hiv.meta[tree.SHARP_hiv.meta$label %in% tree.SHARP_hiv.sub$tip.label, "region.CN"], useNA = "ifany")
```

Note: to zoom in on tree clades, export as PDF (png will not be clear enough).  
Counts: subtree has `r length(tree.SHARP_hiv.sub$edge[,1])` edges, `r tree.SHARP_hiv.sub$Nnode` internal nodes, and `r length(tree.SHARP_hiv.sub$tip.label)` tips (`r tree.SHARP_hiv.sub$Nnode + length(tree.SHARP_hiv.sub$tip.label)` nodes total)  

  
#### SHARP and published
```{r extract subtree - SHARP and published}
tree.hiv.sub <- extract.clade(tree.hiv, 2004)

# Tree structure
str(tree.hiv.sub)
```

```{r extract subtree - SHARP and published 2, fig.width=12, fig.height=8}
is.binary.phylo(tree.hiv.sub)

# Example tree
plot(tree.hiv.sub, main = "SHARP and published - example subtree")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(0, -0.3)) 
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(0, -0.3))
edgelabels(col = "blue", frame = "none")
```


##### IMPORTANT: dropping tips from tree changes tree metadata
```{r extract subtree - SHARP and published 3, fig.width=12, fig.height=8}
tree.hiv.sub.temp <- drop.tip(tree.hiv.sub, "A1.2016.FSW.Coast.Female.MT084981.4052") #Drop the ptid corresponding with tip #2
#print(as_tibble(tree.hiv.sub), n = Inf) #Here at the tibbles for the original and edited trees
#print(as_tibble(tree.hiv.sub.temp), n = Inf)

plot(tree.hiv.sub.temp, main = "SHARP and published - example subtree, with tip dropped")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(0, -0.3)) 
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(0, -0.3))
edgelabels(col = "blue", frame = "none")
```

Counts: subtree has `r length(tree.hiv.sub$edge[,1])` edges, `r tree.hiv.sub$Nnode` internal nodes, and `r length(tree.hiv.sub$tip.label)` tips (`r tree.hiv.sub$Nnode + length(tree.hiv.sub$tip.label)` nodes total)  
Node that if a tip / leaf is dropped from the tree, all corresponding node and branch values change. Therefore, (IMPORTANT), metatree data must be generated from a given tree AFTER any alternations to that tree (ie. after subsampling)



#### Example of uniform Subsampling (downsampling)
Note: For this example, subsampling was done manually and will need to be redone if new subtrees are chosen 
```{r Examples - downsampling trees}
#EXAMPLE - check region distribution in subtree
table(tree.SHARP_hiv.meta[tree.SHARP_hiv.meta$label %in% tree.SHARP_hiv.sub$tip.label, "region.CN"], useNA = "ifany")
uniform_seqs.sub <- tree.SHARP_hiv.meta %>%
  filter(label %in% tree.SHARP_hiv.sub$tip.label & region.CN == "Nairobi") %>% #Select over-represented characteristic
  pull(label) %>%
  sample(6, replace = FALSE) %>% #Sample 6 seqs from Nairobi (change number if example tree changes)
  append(tree.SHARP_hiv.meta[tree.SHARP_hiv.meta$label %in% tree.SHARP_hiv.sub$tip.label & tree.SHARP_hiv.meta$region.CN == "Coast" , "label", drop = TRUE])
tree.SHARP_hiv.sub.u <- ape::drop.tip(tree.SHARP_hiv.sub, tree.SHARP_hiv.sub$tip.label[!(tree.SHARP_hiv.sub$tip.label %in% uniform_seqs.sub)])

#before down-sampling
plot(tree.SHARP_hiv.sub, cex = 0.5, show.tip.label = FALSE)
length(tree.SHARP_hiv.sub$tip.label)

#after down-sampling
plot(tree.SHARP_hiv.sub.u, cex = 0.5, show.tip.label = FALSE, main = )
length(tree.SHARP_hiv.sub.u$tip.label)
```



## SUBSAMPLE TREES (FOR ACTUAL ANALYSIS): 

#### Read in subsampled sequence lists
```{r downsampling trees - SHARP 1}
# down-sample trees based on pre-specified filters
### Specify leaves NOT in the filter (this is because we're using the the ape package drop.tips() function)
#Unifrom
X_Uniform_region_SHARP.seqs.list <-
  lapply(Uniform_region_SHARP.seqs.list, function(x) {
    tree.SHARP_hiv$tip.label[!(tree.SHARP_hiv$tip.label %in% x)]})
X_Uniform_region.seqs.list <-
  lapply(Uniform_region.seqs.list,  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
X_Uniform_risk.seqs.list <-
  lapply(Uniform_risk.seqs.list,  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
X_Uniform_riskregion.seqs.list <-
  lapply(Uniform_regionrisk.seqs.list,  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
#Proportionate (only ended up using proportionate SHARP region)
X_proportionate_region_SHARP.seqs.list <-
  lapply(Proportionate_region_SHARP.seqs.list,  function(x) {
    tree.SHARP_hiv$tip.label[!(tree.SHARP_hiv$tip.label %in% x)]})
X_proportionate_SHARP.seqs.list <-
  lapply(Proportionate_SHARP.seqs.list,  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
X_proportionate_regionrisk.seqs.list <-
  lapply(Proportionate_regionrisk.seqs.list,  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
X_proportionate_regionrisk2.seqs.list <-
  lapply(Proportionate_regionrisk2.seqs.list,  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
#PWID clusters
X_pWID_clust.seqs <- tree.hiv$tip.label[!(tree.hiv$tip.label %in% PWID_cluster.seqs)]
```

#### Drop tips from tree to subsamples
Drop leaves not in the filter
```{r downsampling trees - SHARP 2}
 
## Uniform
trees.Uniform_region_SHARP <- lapply(X_Uniform_region_SHARP.seqs.list[1:n_subsamples_A1], function(x){ape::drop.tip(tree.SHARP_hiv, x)})
trees.Uniform_region <- lapply(X_Uniform_region.seqs.list[1:n_subsamples_A1], function(x){ape::drop.tip(tree.hiv, x)})
trees.Uniform_risk <- lapply(X_Uniform_risk.seqs.list[1:n_subsamples_A1], function(x){ape::drop.tip(tree.hiv, x)})
trees.Uniform_riskregion <- lapply(X_Uniform_riskregion.seqs.list[1:n_subsamples_A1], function(x){ape::drop.tip(tree.hiv, x)})

## Proportionate
trees.proportionate_region_SHARP <- lapply(X_proportionate_region_SHARP.seqs.list[1:n_subsamples_A1.prop], function(x){ape::drop.tip(tree.SHARP_hiv, x)})
trees.proportionate_SHARP <- lapply(X_proportionate_SHARP.seqs.list[1:n_subsamples_A1.prop], 
                                    function(x){ape::drop.tip(tree.SHARP_hiv, x)})
trees.proportionate_regionrisk <- lapply(X_proportionate_regionrisk.seqs.list[1:n_subsamples_A1.prop],
                                         function(x){ape::drop.tip(tree.hiv, x)})
trees.proportionate_regionrisk2 <- lapply(X_proportionate_regionrisk2.seqs.list[1:n_subsamples_A1.prop],
                                          function(x){ape::drop.tip(tree.hiv, x)})
tree.PWID_clust <- ape::drop.tip(tree.hiv, X_pWID_clust.seqs)
```

  

#### Verify expected trait counts (under subsampling)
```{r downsampling trees - SHARP 3}

```
TO DO: ^This
  
  

#### Count number of branches - for ASR tables
```{r downsampling trees - SHARP 4}
nrow(trees.proportionate_region_SHARP[[1]]$edge)
nrow(trees.Uniform_risk[[1]]$edge)
nrow(trees.Uniform_riskregion[[1]]$edge)
```


<br><br>

# ANCESTRAL STATE RECONSTRUCTION: FUNCTIONS (AND EXAMPLES)

## FUNCTION: Transform variable of interest to a phylo object
To extract a variable in the metatree data frame as a PhyData object
```{r phylo_variable function}

phylo_variable <- function(metadata, tree, trait) {
  #INPUTS:
    #metadata: data frame or tibble containing columns: label and the trait of interest (note a metatree can also be provided, which contains columns parent node & branch length corresponding to the tree, but these will be ignored - only the label is used for matching the sequence trait to the corresponding sequence in the tree. Also, the metadata can have more ptids than the tree object - only ptids in the tree will be used)
    #tree: tree object
    #trait (a column in the metatree data frame) passed as a string
  
  #Extract only sequences in tree from data
  metadata <- metadata %>% filter(label %in% tree$tip.label)
  trait_vec <- metadata %>% pull(trait) %>% as.factor()
  names(trait_vec) <- metadata$label
  trait_levels <- sort(as.vector(unique(metadata %>% pull(trait))))
  pd <- phyDat(na.omit(trait_vec), type = 'USER', levels = na.omit(trait_levels))
  
  return(pd)
}


# Similar function, but takes as an input a trait as a vector
phylo_variable2 <- function(trait.m, for_plot = FALSE) {
  #INPUTS:
    #trait.m: a matrix of trait values with labels or ptids as row names
    #for_plot: reformats the phyDat object to work with plotting functions
  trait_levels <- sort(as.vector(na.omit(unique(trait.m[,1]))))

  #convert to PhyDat data type
  pd <- phyDat(trait.m, type = 'USER', levels = trait_levels)
  
  if(for_plot == TRUE){   #Transform to match format expected by plotAnc
    for(i in 1:length(pd)){
      pd[[i]] <- t(matrix(as.double(pd[[i]])))
      pd[[i]] <- abs(1-pd[[i]]) #invert 1 and 0 values for consistent formatting
    }
  }
    
    if(ncol(trait.m)>2){
      attr(pd, "weight") <- 1
      attr(pd, "nr") <- 1
      attr(pd, "nc") <- ncol(trait.m)
      attr(pd, "index") <- 1
      attr(pd, "levels") <- as.character(seq(ncol(trait.m)))
      attr(pd, "allLevels") <- append(as.character(seq(ncol(trait.m))), "?")
    }
  
  #if(ncol(pd[[1]]) == 1){ #we expect to to have at least 2 columns, this is a gimmicky way to accomplish that - it will cause problems if using more than 2 classes, but since this is only for plotting, probably ok
  # pd <- lapply(pd, function(X){matrix(c(X[[1]], 1-X[[1]]), ncol = 2, nrow = 1)})
  #}
  return(pd)
}

# EXAMPLE - SHARP
region_pd.SHARP_hiv.sub <- phylo_variable(tree.SHARP_hiv.meta, tree.SHARP_hiv.sub, "region.CN")
#Example output of PhyDat object 
str(region_pd.SHARP_hiv.sub)
#Example output of PhyDat object (transformed to data frame for better viewing)
t(as.data.frame(region_pd.SHARP_hiv.sub)) 
#Trait distribution 
table(t(as.data.frame(region_pd.SHARP_hiv.sub)))

# EXAMPLE - SHARP (uniform subsampling)
region_pd.SHARP_hiv.sub.u <- phylo_variable(tree.SHARP_hiv.meta, tree.SHARP_hiv.sub.u, "region.CN")
#Example output of PhyDat object (after uniform subsampling) (transformed to data frame for better viewing)
t(as.data.frame(region_pd.SHARP_hiv.sub.u))
#Trait distribution (uniform subsampling)
table(t(as.data.frame(region_pd.SHARP_hiv.sub.u)))

# EXAMPLE - SHARP and published
region_pd.hiv.sub <- phylo_variable(tree.hiv.meta, tree.hiv.sub, "region.CN")

# EXAMPLE - risk
risk_pd.hiv.sub <- phylo_variable(tree.hiv.meta, tree.hiv.sub, "risk4.F")
```

For an example of using phylo_variable2(), see: "plot resolved ancestors"


## Examples: Apply ancestral state reconstruction
#### EXAMPLE - SHARP
```{r Examples - apply ASR 1, fig.width=12, fig.height=8}

#ancestral state assignment using maximum likelihood method
fit.SHARP_hiv.sub <- pml(tree.SHARP_hiv.sub, region_pd.SHARP_hiv.sub)
fit.SHARP_hiv.sub$logLik #log likelihood (note: this will be astronomically small for larger trees)
region_ap.SHARP_hiv.sub <- ancestral.pml(fit.SHARP_hiv.sub, "ml")

plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.sub, cex = 0.5,
        main = "Example SHARP ASR - region")


#Explore ASR output
print(do.call(rbind.data.frame, region_ap.SHARP_hiv.sub)) #(transformed to data frame for better viewing)
length(region_ap.SHARP_hiv.sub)

#CHECK that state probabilities sum to 1 
all(abs(unname(apply(do.call(rbind.data.frame, region_ap.SHARP_hiv.sub), 1, sum))-1)<0.001) #(This allows for very slight rounding errors by subtracting 1 from the state values and checking that the difference is not >0.001)
```
   
#### EXAMPLE - SHARP with uniform subsampling. Verify there are 6 (V1) coast and 9 Nairobi (V2) seqs
```{r Examples - apply ASR 2, fig.width=12, fig.height=8}

#ancestral state assignment using maximum likelihood method
fit.SHARP_hiv.sub.u <- pml(tree.SHARP_hiv.sub.u, region_pd.SHARP_hiv.sub.u)
region_ap.SHARP_hiv.sub.u  <- ancestral.pml(fit.SHARP_hiv.sub.u, "ml")

plotAnc(tree.SHARP_hiv.sub.u, region_ap.SHARP_hiv.sub, cex = 0.5,
        main = "Example SHARP ASR - region (Uniform Subsampling)")
```
Note: most ancestral seqs have a higher prob of being assigned Nairobi. This is not surprising given that there are more Nairobi seqs.    


#### EXAMPLE - SHARP and published
```{r Examples - apply ASR 3, fig.width=12, fig.height=8}
fit.hiv.sub <- pml(tree.hiv.sub, region_pd.hiv.sub)
fit.hiv.sub$logLik #log likelihood
region_ap.hiv.sub <- ancestral.pml(fit.hiv.sub, "ml")

plotAnc(tree.hiv.sub, region_ap.hiv.sub, cex = 0.5, show.tip.label = FALSE,
        main = "Example SHARP and Published ASR - region")

#Check distribution of trait in the subtree matches what's expected based on the metadata - yes it does
tree.hiv.meta[tree.hiv.meta$label %in% tree.hiv.sub$tip.label, c("label", "region.CN")]
table(tree.hiv.meta[tree.hiv.meta$label %in% tree.hiv.sub$tip.label, "region.CN"])

#CHECK that state probabilities sum to 1 
all(abs(unname(apply(do.call(rbind.data.frame, region_ap.hiv.sub), 1, sum))-1)<0.001)
```
  
  
### EXAMPLE - risk
```{r Examples - apply ASR 4, fig.width=12, fig.height=8}
risk_fit.hiv.sub <- pml(tree.hiv.sub, risk_pd.hiv.sub)
risk_ap.hiv.sub <- ancestral.pml(risk_fit.hiv.sub, "ml")
plotAnc(tree.hiv.sub, risk_ap.hiv.sub, cex = 0.5, show.tip.label = FALSE,
        main = "Example SHARP and Published ASR - risk population")

#CHECK that state probabilities sum to 1 
all(abs(unname(apply(do.call(rbind.data.frame, risk_ap.hiv.sub), 1, sum))-1)<0.001) 
```

### EXPLORATORY: try different types of ancestral state reconstruction  
Phangorn (ancestral reconstruction package) has 2 different function for performing ancestral state reconstruction, depending on the algorithm. "MPR" and "ACCTRAN" are parsimony methods and use ancestral.pars() function. Likelihood and Bayesian methods - "my", "marginal", and "bayes" - use the ancestral.pml() function, which requires an object (fit) of type "pml"
```{r explore types of ASR 1}
# SHARP 

# Parsimony methods
region_ap.SHARP_hiv.MPR <- ancestral.pars(tree.SHARP_hiv.sub, region_pd.SHARP_hiv.sub, type = "MPR")
MPR <- do.call(rbind.data.frame, region_ap.SHARP_hiv.MPR)[, 1, drop = FALSE] #Since it's a binary trait, we only need one column to infer the trait

region_ap.SHARP_hiv.ACCTRAN <- ancestral.pars(tree.SHARP_hiv.sub, region_pd.SHARP_hiv.sub, type = "ACCTRAN")
ACCTRAN <- do.call(rbind.data.frame, region_ap.SHARP_hiv.ACCTRAN)[, 1, drop = FALSE]

# ML methods
fit.SHARP_hiv.sub <- pml(tree.SHARP_hiv.sub, region_pd.SHARP_hiv.sub) #convert to pml object (expected format for phangorn package)
region_ap.SHARP_hiv.ml <- ancestral.pml(fit.SHARP_hiv.sub, "ml")
ml <- do.call(rbind.data.frame, region_ap.SHARP_hiv.ml)[, 1, drop = FALSE]

region_ap.SHARP_hiv.marginal <- ancestral.pml(fit.SHARP_hiv.sub, "marginal")
marginal <- do.call(rbind.data.frame, region_ap.SHARP_hiv.marginal)[, 1, drop = FALSE]

#ML - rate optimized
fit.SHARP_hiv.sub2 <- optim.pml(fit.SHARP_hiv.sub, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) #after optimizing rate
region_ap.SHARP_hiv.ml2 <- ancestral.pml(fit.SHARP_hiv.sub2, "ml")
ml_rate_optimized <- do.call(rbind.data.frame, region_ap.SHARP_hiv.ml2)[, 1, drop = FALSE]

#ML - branch length optimized
fit.SHARP_hiv.sub3 <- optim.pml(fit.SHARP_hiv.sub, optEdge = TRUE, optRate=FALSE,
                                control = pml.control(trace=0), rearrangement = "none") #IMPORTANT: do not allow rearrangement of branches!
region_ap.SHARP_hiv.ml3 <- ancestral.pml(fit.SHARP_hiv.sub3, "ml")
ml_branch_optimized <- do.call(rbind.data.frame, region_ap.SHARP_hiv.ml3)[, 1, drop = FALSE]

#ML - rate and branch length optimized
fit.SHARP_hiv.sub4 <- optim.pml(fit.SHARP_hiv.sub2, optEdge = TRUE, optRate=FALSE,
                                control = pml.control(trace=0), rearrangement = "none")
region_ap.SHARP_hiv.ml4 <- ancestral.pml(fit.SHARP_hiv.sub4, "ml")
ml_rateandbranch_optimized <- do.call(rbind.data.frame, region_ap.SHARP_hiv.ml3)[, 1, drop = FALSE]

#Bayesian methods
region_ap.SHARP_hiv.bayes <- ancestral.pml(fit.SHARP_hiv.sub, "bayes")
bayes <- do.call(rbind.data.frame, region_ap.SHARP_hiv.bayes)[, 1, drop = FALSE]
```

#### Plot results from different ASR methods
```{r explore types of ASR 2, fig.width=10, fig.height=12}
par(mfrow=c(3,3))
plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.MPR,
        main = "MPR", show.tip.label = FALSE)
plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.ACCTRAN, main = "ACCTRAN",
        pos = NULL, show.tip.label = FALSE)
plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.ml, main = "maximum likelihood",
        pos = NULL, show.tip.label = FALSE)
plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.marginal, main = "marginal",
        pos = NULL, show.tip.label = FALSE)
plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.ml2, main = "maximum likelihood - rate optimized",
        pos = NULL, show.tip.label = FALSE)
plotAnc(unroot(tree.SHARP_hiv.sub), region_ap.SHARP_hiv.ml3, main = "maximum likelihood - branch optimized",
        pos = NULL, show.tip.label = FALSE)
plotAnc(unroot(tree.SHARP_hiv.sub), region_ap.SHARP_hiv.ml4, main = "maximum likelihood -\nrate and branch optimized",
        pos = NULL, show.tip.label = FALSE)

plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.bayes, main = "Baysian",
        pos = NULL, show.tip.label = FALSE)

par(mfrow=c(1,1)) #reset

```

Note that the rate-optimized ML tree appears to assigns probability to each state for all ancestors. This did not happen when actually running in the larger trees, so it may be the result of of too much uncertainty for smaller trees?  

TO DO: ^Double-check this  



#### Print table of assignements from different ASR methods
```{r explore types of ASR 3}
ml_branch_optimized[29,] <- NA #root node was dropped, so add back in
ml_rateandbranch_optimized[29,] <- NA

parse_types <- suppressWarnings({bind_cols(MPR, ACCTRAN, ml, marginal,
                         ml_rate_optimized, ml_branch_optimized, ml_rateandbranch_optimized,
                         bayes)})

colnames(parse_types) <- c("MPR", "ACCTRAN", "ml", "marginal",
                           "ml - rate optimized", "ml - branch optimized", "ml - rate and branch optimized",
                           "bayes")

kable(parse_types)

```
  

ML, marginal, and Bayes all agree. There is not much agreement across the other methods (or after optimizing rate or branch length); however, things tend to be more consistent for larger trees. 
  

**Background on ASR with Phangorn Package:**
  * See:  https://mran.microsoft.com/snapshot/2016-02-26/web/packages/phangorn/vignettes/Ancestral.pdf  
  * "All the ancestral reconstructions for parsimony are based on the fitch algorithm."  
  * "'MPR' reconstructs the ancestral states for each
(internal) node as if the tree would be rooted in that node. However the nodes are
not independent of each other."  
  * "The advantages of ML over parsimony is that the reconstruction accounts for different edge
lengths."  
Note: I found that all of these methods produce the same result, every iteration (they do not incorporate randomness). ie. if you rerun the script above and assign to a new object, the parse_types data frames will be identical.  


## FUNCTION: resolve ancestors
#### Returns a list of 2 arrays: The first is unresolved (includes probabilities) nodestates, the second is resolved (all are 0 or 1)
```{r resolve_ancestors function}
resolve_ancestors <- function(ap, only_resolved = FALSE) {
  #ap = a phyDat object with parsed ancestral trait values for all nodes (internal nodes may be probabilities). In this example, Coast = 1, Nairobi = 2 (need to figure out how to make this explicit in code)
  #Only resolved: instead of returning a list of 2 data frames, just returns the revolved data frame
  
  #If the levels are not in alphabetical order (ex.Coast, Nairobi), throw an error
  if(!all(levels(ap) == sort(levels(ap)))){ 
    stop("Levels are not in expected alphabetical order")
  }
  
  nodeStates <- as.data.frame(t(sapply(subset(ap, select = 1, site.pattern = TRUE), as.numeric))) #as.data.frame() seems to be causing problems
  
  #Separate nodeStates into observed (not to be edited) and Unresolved
  N_leaves <- ceiling((nrow(nodeStates)+1)/2)
  Observed <- nodeStates[1:N_leaves,]
  Unresolved <- nodeStates[(N_leaves+1):nrow(nodeStates),]
  
#Probability of returning a nodestate of 1 = 
  Resolved <- apply(as.data.frame(Unresolved), 1, function(X) {
    nodestate_1 <- sample(1:length(X), length(X), prob = X, replace = FALSE) #assign one of the nodestates the value 1 (based on the given probabilities of each nodestate (X is these probabilities) - note that for many nodes early in the tree, the probability for one node is already rounded to 1)
    X[nodestate_1[1]] <- 1 #assign that position 1
    X[nodestate_1[-1]] <- 0 #assign all other positions 0
    return(X)
  }) %>% t()
  
  
  nodeStates_Resolved <- as.matrix(rbind(Observed, Resolved))

  #Check
  if(!(nrow(nodeStates) == nrow(nodeStates_Resolved))){
    stop("number of rows in nodeStates_Resolved does not match number of rows in nodeStates")
  }
  
  if(only_resolved == TRUE){
    return(nodeStates_Resolved)
  } else { 
    return(list(nodeStates = nodeStates, nodeStates_Resolved = nodeStates_Resolved))
  }
}

# EXAMPLE - SHARP
set.seed(1)
nodeStates.SHARP_hiv_sub <- resolve_ancestors(region_ap.SHARP_hiv.sub)

# EXAMPLE - SHARP (after optimizing rate)
set.seed(1)
nodeStates.SHARP_hiv_sub2 <- resolve_ancestors(region_ap.SHARP_hiv.ml2)
optim_to_non_optim <- cbind(
  nodeStates.SHARP_hiv_sub$nodeStates_Resolved[-nrow(nodeStates.SHARP_hiv_sub$nodeStates_Resolved), 1],
  nodeStates.SHARP_hiv_sub2$nodeStates_Resolved[, 1]) #compare to nodestates for non-optimized tree
optim_to_non_optim[16:nrow(optim_to_non_optim),] %>% as.data.frame() %>%
  rename(not_optimized = V1, optimized = V2) %>% table()

# EXAMPLE - SHARP (after optimizing branches)
set.seed(1)
nodeStates.SHARP_hiv_sub3 <- resolve_ancestors(region_ap.SHARP_hiv.ml3)
optim_to_non_optim <- cbind(nodeStates.SHARP_hiv_sub$nodeStates_Resolved[-nrow(nodeStates.SHARP_hiv_sub$nodeStates_Resolved),1], nodeStates.SHARP_hiv_sub3$nodeStates_Resolved[,1]) #compare to nodestates for non-optimized tree (note: drop root asignment because optimized tree is unrooted)
optim_to_non_optim[16:nrow(optim_to_non_optim),] %>% as.data.frame() %>% #For ancestor nodes (start at node 16)
  rename(not_optimized = V1, optimized = V2) %>% table()

# EXAMPLE - SHARP (after optimizing rate and branches)
set.seed(1)
nodeStates.SHARP_hiv_sub4 <- resolve_ancestors(region_ap.SHARP_hiv.ml4)
optim_to_non_optim <- cbind(
  nodeStates.SHARP_hiv_sub$nodeStates_Resolved[-nrow(nodeStates.SHARP_hiv_sub$nodeStates_Resolved), 1],
  nodeStates.SHARP_hiv_sub4$nodeStates_Resolved[, 1]) #compare to nodestates for non-optimized tree
optim_to_non_optim[16:nrow(optim_to_non_optim),] %>% as.data.frame() %>%
  rename(not_optimized = V1, optimized = V2) %>% table()


# EXAMPLE - SHARP with uniform subsampling
nodeStates.SHARP_hiv_sub.u <- resolve_ancestors(region_ap.SHARP_hiv.sub.u)

# EXAMPLE - SHARP and published
nodeStates.hiv_sub <- replicate(n_parsimony, resolve_ancestors(region_ap.hiv.sub, only_resolved = TRUE), simplify = FALSE)

# EXAMPLE - SHARP (risk)
risk_nodeStates.hiv_sub <- replicate(n_parsimony, resolve_ancestors(risk_ap.hiv.sub, only_resolved = TRUE), simplify = FALSE)
```



### EXPLORATORY - Demonstrate different ways ancestors can be resolved
Randomly resolving the ancestor state probabilities determined using the maximum likelihood method   
```{r demonstrate ways ancestors can be resolved, fig.width=8, fig.height=20}
#EXAMPLE Plot - this shows the different trees you get from randomly resolving ancestral states
layout(matrix(1:15, ncol = 3))
plots <- list()
set.seed(17)

for(i in 1:15){
  nodeStates.SHARP_hiv.sub <- resolve_ancestors(region_ap.SHARP_hiv.sub)
  region_ap.SHARP_hiv.sub_resolved <- phylo_variable2(nodeStates.SHARP_hiv.sub$nodeStates_Resolved, for_plot = TRUE)
  plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.sub_resolved, pos = NULL, cex = 1.5, show.tip.label = FALSE)
}

par(mfrow=c(1,1))
```
In this example, most ancestors are resolved as being from Nairobi. Since most ancestor probabilities are relatively unambiguous, I decided to drop the number of "random" resolutions from 20 to 10, as I don't think this represents a large amount of the uncertainty in the ASR.  


  


### Plot examples of nodestate resolutions
```{r transition tree plot examples 1, fig.width=20, fig.height=10}


## Region ##

# EXAMPLE - how nodes and edges are labeled by region before resolving internal nodes
png(paste0(save_path, "examples/subtree_LabelsandNodestates_Unresolved_region.png"),
    height = 20, width = 20, units = "in", res = 1000)
plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.ml, cex = 0.7, show.tip.label = FALSE,
        main = "SHARP - Region (Unresolved)")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
edgelabels(col = "blue", bg = "white", adj = c(0, -0.5))
dev.off()
#Also print to screen:
knitr::include_graphics(paste0(save_path, "examples/subtree_LabelsandNodestates_Unresolved_region.png"))

# EXAMPLE - how nodes and edges are labeled by region after resolving internal nodes
png(paste0(save_path, "examples/subtree_LabelsandNodestates_region.png"),
    height = 20, width = 20, units = "in", res = 1000)
plotAnc(tree.SHARP_hiv.sub, region_ap.SHARP_hiv.sub_resolved, cex = 0.7, show.tip.label = FALSE, 
        main = "SHARP - Region (resolved)")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
edgelabels(col = "blue", bg = "white", adj = c(0, -0.5))
dev.off()
#Also print to screen:
knitr::include_graphics(paste0(save_path, "examples/subtree_LabelsandNodestates_region.png"))


# Example - how nodes and edges are labeled by region before resolving internal nodes (using rate and branch-length optimization)
png(paste0(save_path, "examples/subtree_LabelsandNodestates_unresolved_region_optimized_rate_branches.png"),
    height = 20, width = 20, units = "in", res = 1000)
plotAnc(unroot(tree.SHARP_hiv.sub), region_ap.SHARP_hiv.ml4, cex = 0.7, show.tip.label = FALSE, 
        main = "SHARP - Region\n(rate and branch length opimized) (Unresolved)")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
edgelabels(col = "blue", bg = "white", adj = c(0, -0.5))
dev.off()
#Also print to screen:
knitr::include_graphics(paste0(save_path,
  "examples/subtree_LabelsandNodestates_unresolved_region_optimized_rate_branches.png"))

# Example - how nodes and edges are labeled by region after resolving internal nodes (using rate and branch-length optimization)
png(paste0(save_path, "examples/subtree_LabelsandNodestates_region_optimized_rate_branches.png"),
    height = 20, width = 20, units = "in", res = 1000)
plotAnc(unroot(tree.SHARP_hiv.sub),
        phylo_variable2(nodeStates.SHARP_hiv_sub4$nodeStates_Resolved, for_plot = TRUE), cex = 0.7, 
        show.tip.label = FALSE, main = "SHARP - Region\n(rate and branch length opimized) (resolved)")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
edgelabels(col = "blue", bg = "white", adj = c(0, -0.5))
dev.off()
#Also print to screen:
knitr::include_graphics(paste0(save_path,
  "examples/subtree_LabelsandNodestates_region_optimized_rate_branches.png"))



## Risk ##

# EXAMPLE - how nodes and edges are labeled by risk group (before resolving internal nodes)
png(paste0(save_path, "examples/subtree_LabelsandNodestates_unresolved_risk.png"),
    height = 20, width = 20, units = "in", res = 1000)
plotAnc(tree.hiv.sub, risk_ap.hiv.sub, cex = 0.7, show.tip.label = FALSE,
        main = "SHARP and published - Risk (Unresolved)")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
edgelabels(col = "blue", bg = "white", adj = c(0, -0.5))
dev.off()
knitr::include_graphics(paste0(save_path,
  "examples/subtree_LabelsandNodestates_unresolved_risk.png"))


# EXAMPLE - how nodes and edges are labeled by risk group (after resolving internal nodes)
png(paste0(save_path, "examples/subtree_LabelsandNodestates_resolved_risk.png"), height = 20, width = 20, units = "in", res = 1000)
plotAnc(tree.hiv.sub, phylo_variable2(risk_nodeStates.hiv_sub[[1]], for_plot = TRUE), cex = 0.7,
         show.tip.label = FALSE, main = "SHARP and published - Risk (Resolved)")
nodelabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
tiplabels(col = "red", frame = "none", bg = "transparent", adj = c(-0.5, -0.5))
edgelabels(col = "blue", bg = "white", adj = c(0, -0.5))
dev.off()
knitr::include_graphics(paste0(save_path,
  "examples/subtree_LabelsandNodestates_resolved_risk.png"))


```



## FUNCTION: get list of imports and exports based on resolved ancestors 
The Count object:
  * Each list has length = all nodes on the tree and records the "child" (descendant node) numbers for all transitions matching that type
  * Transitions represent all possible binary combinations of states (& where the states don't match) specify a direction. For a binary trait, the transitions are: within 1, within 2, trans_1to2, trans_2to1 (note: for >2 categories, there will be more transition types)
  *  Separate lists record the nodestate of the parent and child (allows manual verification of correct transition assignments) as well as whether the given descendant node is a leaf (terminal node) and whether that leaf is a SHARP sequence (SHARP child). This was used as a sensitivity check (looking at transitions on terminal branches only) because trees tended to converge near the root.  
  
The count object in conjunction with a node-labeled tree, allows for easy manual checking of the trait summary stats.


```{r count_transitions2_function}
count_transitions2 <- function(tree, nodestates) {
  #This function should work for any number of categories, but it's a bit convoluted, so I recommend using count_transitions if just using 2 categories
  iedge <- rev(postorder(tree)) 

  # Initialize empty vectors
  output_NAs <- rep(NA, Nnode(tree) + Ntip(tree))
  trans_list<- replicate((ncol(nodestates)^2) + 4, output_NAs, simplify = FALSE)
  
  #Add transition names (technically we could leave the lists empty and names woudl be assigned as needed, but this is easier to keep track fo this way)
  trans_list_names <- c()
  for(i in 1:ncol(nodestates)){
    trans_list_names <- append(trans_list_names, paste0("within_",i))
    for(j in 1:ncol(nodestates)){
      if(i != j) {
        trans_list_names <- append(trans_list_names, paste0("trans_",i, "to", j))}
    }
  }
  
  trans_list_names <- append(trans_list_names, c("leaves", "SHARP_child", "nodestates.C", "nodestates.P"))   #Also add names for other counts of interest

  names(trans_list) <- trans_list_names
  

  for (k in 1:length(iedge)) {
    i <- iedge[k] 
    u <- tree$edge[i,1] 
    v = tree$edge[i,2] 

    parent_state <- which(nodestates[u,] == 1)
    child_state <- which(nodestates[v,] == 1)
    
    if(parent_state == child_state){
      trans_type <- paste0("within_", parent_state)
    } else {
      trans_type <- paste0("trans_", parent_state, "to", child_state)
    }
    
    trans_list[[trans_type]][v] <- v
    
    if(!(v %in% tree$edge[,1])){ 
      trans_list[["leaves"]][v] <- v 
    }
    if(row.names(nodestates)[v] %in% SHARP_seq_names){ 
      trans_list[["SHARP_child"]][v] <- v
    }
    trans_list[["nodestates.C"]][v] <- which(nodestates[v,] == 1) 
    trans_list[["nodestates.P"]][v] <- which(nodestates[u,] == 1)
  }
  
  root.node <- setdiff(tree$edge[,1], tree$edge[,2])
  trans_list[["nodestates.C"]][root.node] <- which(nodestates[root.node,] == 1)
    
  return(trans_list)
}


## Example outputs ##

# EXAMPLE - SHARP
transitions.SHARP_hiv.sub <- count_transitions2(tree.SHARP_hiv.sub, nodeStates.SHARP_hiv_sub$nodeStates_Resolved)
print("SHARP - Region")
print(transitions.SHARP_hiv.sub)

# EXAMPLE - SHARP with uniform subsampling
transitions.SHARP_hiv_sub.u <- count_transitions2(tree.SHARP_hiv.sub.u, nodeStates.SHARP_hiv_sub.u$nodeStates_Resolved) #uniform subsampling
print("SHARP - Uniform Subsampling - Region")
print(transitions.SHARP_hiv_sub.u)

# EXAMPLE - SHARP and published (multiple parsimony, but I'm only printing the 1st)
transitions.hiv_sub <- lapply(nodeStates.hiv_sub, count_transitions2, tree = tree.hiv.sub)
print("SHARP and Published - Region")
print(transitions.hiv_sub[[1]])

# EXAMPLE - SHARP - risk (multiple parsimony, but I'm only printing the 1st)
risk_transitions.hiv.sub2 <- lapply(risk_nodeStates.hiv_sub, count_transitions2, tree = tree.hiv.sub)
print("SHARP and Published - Risk")
risk_transitions.hiv.sub2[1:2]

```



## FUNCTION: Sum number of imports and exports given a transitions count object
```{r summarize_transitions function}
summarize_transitions <- function(transition_counts, SHARP_only = FALSE,
                                  categories_0_1 = c(1,2), simplify = FALSE) {
  #If SHARP_only is set to TRUE, only transition_counts ending in SHARP sequences will be counted. 
  #categories 0 1 is a numeric or character vector indicating the names of the categories that should be treated at the 0 and 1 values (since R has 0,1 coding, for a binary variable this is usually going to be c(1,2) - the default)
  category0 <- categories_0_1[1]
  category1 <- categories_0_1[2]
  
  trans_1to0 = paste0("trans_", category1, "to", category0)
  trans_0to1 = paste0("trans_", category0, "to", category1)
  within_1 = paste0("within_", category1)
  within_0 =  paste0("within_", category0)
  
  if(SHARP_only == "FALSE"){
    transitions <- list(
        #Summary statistics for just the SHARP leaves (observed sequences):
        trans_1to0_leaves = sum(!is.na(transition_counts[[trans_1to0]]) & !is.na(transition_counts$leaves)),
        trans_0to1_leaves = sum(!is.na(transition_counts[[trans_0to1]]) & !is.na(transition_counts$leaves)),
        within_1_leaves = sum(!is.na(transition_counts[[within_1]]) & !is.na(transition_counts$leaves)),
        within_0_leaves = sum(!is.na(transition_counts[[within_0]]) & !is.na(transition_counts$leaves)),
        #Summary stats for full tree
        trans_1to0 = sum(!is.na(transition_counts[[trans_1to0]])),
        trans_0to1 = sum(!is.na(transition_counts[[trans_0to1]])),
        within_1 = sum(!is.na(transition_counts[[within_1]])),
        within_0 = sum(!is.na(transition_counts[[within_0]]))
    )
  }
  
    if(SHARP_only == "TRUE"){
      transitions <- list(
          #Summary statistics for just the SHARP leaves (observed sequences):
          trans_1to0_leaves = sum(!is.na(transition_counts[[trans_1to0]]) & !is.na(transition_counts$leaves) & !is.na(transition_counts$SHARP_child)),
          trans_0to1_leaves = sum(!is.na(transition_counts[[trans_0to1]]) & !is.na(transition_counts$leaves) & !is.na(transition_counts$SHARP_child)),
          within_1_leaves = sum(!is.na(transition_counts[[within_1]]) & !is.na(transition_counts$leaves) & !is.na(transition_counts$SHARP_child)),
          within_0_leaves = sum(!is.na(transition_counts[[within_0]]) & !is.na(transition_counts$leaves) & !is.na(transition_counts$SHARP_child)),
          #Summary stats for full tree
          trans_1to0 = sum(!is.na(transition_counts[[trans_1to0]])),
          trans_0to1 = sum(!is.na(transition_counts[[trans_0to1]])),
          within_1 = sum(!is.na(transition_counts[[within_1]])),
          within_0 = sum(!is.na(transition_counts[[within_0]]))
      )
    }
      
    if(simplify == TRUE){
      return(do.call(rbind, transitions))
    } else {
      return(transitions)
    }
}

# EXAMPLE - SHARP
set.seed(11)
print("SHARP - Region")
summarize_transitions(transitions.SHARP_hiv.sub)

# EXAMPLE - risk - Extract separate counts for each pair of risk groups
set.seed(11)
#CHECK risk categories in data - these should be alphabetical!
tree.hiv.meta %>% 
  filter(label %in% tree.hiv.sub$tip.label) %>%
  reframe(levels(factor(risk4.F)))
tree.hiv.meta %>% #all possible factor levels - WARNING: these are what inform the number associated with each category (so even categories not present do get counted - for this reason, it is advisable to entirely remove categories not of interest before ancestral state reconstructions)
  reframe(levels(factor(risk4.F)))
print("FSW & MSM")
FSW_MSM_transitions.hiv.sub <- summarize_transitions(risk_transitions.hiv.sub2[[1]],
  categories_0_1 = c(1,3))
FSW_MSM_transitions.hiv.sub
print("FSW & HET")
FSW_HET_transitions.hiv.sub <- summarize_transitions(risk_transitions.hiv.sub2[[1]],
  categories_0_1 = c(1,2))
FSW_HET_transitions.hiv.sub
print("MSM & HET")
MSM_HET_transitions.hiv.sub <- summarize_transitions(risk_transitions.hiv.sub2[[1]],
  categories_0_1 = c(3,2))
MSM_HET_transitions.hiv.sub
print("PWID & HET")
MSM_HET_transitions.hiv.sub <- summarize_transitions(risk_transitions.hiv.sub2[[1]],
  categories_0_1 = c(4,2))
MSM_HET_transitions.hiv.sub

# EXAMPLE - risk (multiple parsimony)
print("MSM & HET (Multiple Parsimony")
FSW_HET_transitions.hiv.sub <- lapply(risk_transitions.hiv.sub2, summarize_transitions, categories_0_1 = c(3,2)) %>% do.call(rbind, .) %>% t()
FSW_HET_transitions.hiv.sub[,1:3]
```




## FUNCTION: Combined function - Resolve ancestral states and calculate number of imports and exports
#### This combines the several of the above functions (resolve_ancestors, count_transitions, and summarize_transitions) - which is useful when we want to replicate these steps several times. For binary traits only.   
```{r resolve_and_summarize_transitions function}
resolve_and_summarize_transitions <- function(ap, tree, SHARP_only = FALSE) {
  #If SHARP_only is set to TRUE, only transitions ending in SHARP sequences will be counted. 
  nodeStates <- resolve_ancestors(ap)
  transitions <- count_transitions2(tree, nodeStates$nodeStates_Resolved)
  return(summarize_transitions(transitions))
}


# EXAMPLE - SHARP
set.seed(11)
print("SHARP - Region")
resolve_and_summarize_transitions(region_ap.SHARP_hiv.sub, tree.SHARP_hiv.sub)

# EXAMPLE - SHARP - multiple parsimony (note: not printed)
#(save an example resolving parsimony multiple times (this has randomness built in, so results will differ for each run)
transitions.SHARP_hiv_sub <- replicate(n_parsimony, resolve_and_summarize_transitions(region_ap.SHARP_hiv.sub, tree.SHARP_hiv.sub))

# EXAMPLE - SHARP with uniform subsampling - multiple parsimony (note: not printed)
transitions.SHARP_hiv_sub.u2 <- replicate(n_parsimony, resolve_and_summarize_transitions(region_ap.SHARP_hiv.sub.u, tree.SHARP_hiv.sub.u)) #uniform subsampling

# EXAMPLE - SHARP and published (note: not printed)
print("SHARP and Published - Region")
resolve_and_summarize_transitions(region_ap.hiv.sub, tree.hiv.sub, SHARP_only = TRUE)

```
Don't use this for non-binary traits like risk: because we want to summarize each pair of between-group transitions according for each resolution (if we use resolve_and_summarize_transitions, we would have to re-resolve transitions separated for each pair of categories). This ended up not being very useful, as most traits I looked at ended up being >2 categories.  


## FUNCTION: resample leaf assignments (for permutation)
#### Randomly resamples tree tips (ie. the non-NA region values) - the pd variable is returned to match the original pd variable but with trait assignments randomly shuffled (internal nodes will still be NA, as these are not yet assigned). Note: the relative freqeuncy of each trait is mantained.
```{r resample_metatree function}
resample_trait <- function(pd) {
  #meta_tree metadata-tree type data frame or tibble containing columns: parent node, branch.length, label, and the trait of interest
  #pd: a PhyDat object of the true trait assignments. Internal (ancestor) nodes are NA
  pd.df <- pd %>%
    as.data.frame() %>% t() #extract randomized vector of trait values
  resampled_variable <- pd.df  %>% sample(replace = FALSE)
  
  resampled.m <- data.frame(trait = resampled_variable) %>% as.matrix()
  row.names(resampled.m) <- names(pd)
  resampled_pd <- phylo_variable2(resampled.m)
  
  #check that levels are in alphabetical order:
  if(!all(sort(unique(pd.df[,1])) == levels(resampled_pd))){
    stop("Factor levels are not alphabetical")
  }
  
  #check that resample counts match counts for tree tips
  if(!all(table(pd.df[,1]) == table(resampled.m[,1]))){
    stop("Resampled counts don't match original counts for each trait")
  }
  
  #check that phylo_variable did not change assignment / factor levels / counts
  if(!identical(table(table(t(as.data.frame(resampled_pd)))), table(table(pd.df)))){
    stop("Resampled counts don't match original counts for each trait")
  }

  return(resampled_pd)
}

##

# EXAMPLE - SHARP 
set.seed(11)
print("SHARP - Region")
region_pd.SHARP_hiv.sub.resampled <- resample_trait(region_pd.SHARP_hiv.sub)
#Confirm correct re sampling - total counts of each region should be the same in each (this is confirmed in the script as well)
addmargins(table(true = t(as.data.frame(region_pd.SHARP_hiv.sub))[,1], resampled = t(as.data.frame(region_pd.SHARP_hiv.sub.resampled))[,1], useNA = "ifany"))

# EXAMPLE - SHARP with uniform subsampling
set.seed(11)
print("SHARP - Uniform subsampling - Region")
region_pd.SHARP_hiv.sub.u.resampled <- resample_trait(region_pd.SHARP_hiv.sub.u)
#Confirm correct re sampling
addmargins(table(true = t(as.data.frame(region_pd.SHARP_hiv.sub.u))[,1], resampled = t(as.data.frame(region_pd.SHARP_hiv.sub.u.resampled))[,1], useNA = "ifany"))

# EXAMPLE - risk
set.seed(11)
print("SHARP and published - Risk")
risk_pd.hiv.sub.resampled <- resample_trait(risk_pd.hiv.sub)
#Confirm correct re sampling - total counts of each region should be the same in each (this is confirmed in the script as well)
addmargins(table(true = t(as.data.frame(risk_pd.hiv.sub))[,1], resampled = t(as.data.frame(risk_pd.hiv.sub.resampled))[,1], useNA = "ifany"))

```

Totals for each region (or risk) are the same between original data and resample, as expected.  


## FUNCTION: Permute import export counts
This is a function to calculate the imports and exports numbers across multiple permutations (permutations and resamplings are the same thing)

```{r permute_tree function}
permute_tree <- function(pd, tree, parsimony_method, optimize = TRUE, optimize.edge = FALSE, SHARP_only = FALSE, summarize = FALSE) {
  #pd: phyDat object of sequence names associated with trait assignments
  #tree: tree of phylo type - must have sequence names exactly marching those in pd
  #optimize: whether to optimize rates when doing ASR. WARNING, optimize argument only matters for ml method. For all other methods, this argument is ignored. IMPORTANT: use of optimize (meaning optimize rate) and optimize.edge to do ASR in the permuted trees needs to match use of optimize when doign ASR in the true tree.
  #optimize.edge: whether to optimize edge lengths when doing ASR. WARNING, optimize argument only matters for ml method. For all other methods, this argument is ignored
  #If SHARP_only is true, only SHARP sequences will be counted (use cautiously!) - I didn't end up using this in analyses
  #If summarize is TRUE, the number of transitions will be summarized and only the total count of each number of transitions will be returned. This should only be used for binary traits
  
  # CHECK!
  if(!identical(sort(names(pd)), sort(tree$tip.label))){
    stop("tip names in pd object differ from tree")
  }
  
  #Re-sample the trait from the pd object
  pd.resample <- resample_trait(pd)
  
  if(parsimony_method == "ml" | parsimony_method == "marginal" | parsimony_method == "baysian"){
    #For some reason, phangorn requires different inputs to perform parsimony with different methods, this makes sure the right input is used for the right methods
    fit.resample <- pml(tree, pd.resample)
    if(optimize == TRUE){ #optional: optimize rates (may be necessary in order to get ASR values)
      fit.resample <- optim.pml(fit.resample, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
    }
    if(optimize.edge == TRUE){ #optional: optimize edge lengths (may be necessary in order to get ASR values)
       fit.resample <- optim.pml(fit.resample, optEdge = TRUE, optRate=FALSE, control = pml.control(trace=0), rearrangement = "none")
    }
    ap.resample <- ancestral.pml(fit.resample, parsimony_method) #get ancestral assignments using probability methods
  } else {
    ap.resample <- ancestral.pars(tree, pd.resample, type = parsimony_method) #alternatively, get ancestral assignments using parsimony methods
  }
  
  resolved <- replicate(n_parsimony, resolve_ancestors(ap.resample)$nodeStates_Resolved, simplify = FALSE)
  if(optimize.edge == TRUE){ #If optimizing edge lengths, the tree is unrooted, so we have to use the unrooted tree in the counts as well
    transition_counts <- lapply(resolved, count_transitions2, tree = unroot.phylo(tree))
  } else {
    transition_counts <- lapply(resolved, count_transitions2, tree = tree)
  }

  if(summarize == TRUE){ #generally only use for binary traits, otherwise, we'll want to extract multiple summaries from the count object
    transition_sums <- lapply(transition_counts, summarize_transitions)
    return(transition_sums)
  } else {
    return(transition_counts)
  }
  
}

# EXAMPLE - SHARP
print("SHARP - Region (2 parsimonies)")
transition_counts.permuted.SHARP_hiv.sub1 <- permute_tree(region_pd.SHARP_hiv.sub, tree.SHARP_hiv.sub,
                                                          parsimony_method = "ml")
transition_counts.permuted.SHARP_hiv.sub1[1:2]

# EXAMPLE - SHARP - multiple permutations (note: not printed)
transition_counts.permuted.SHARP_hiv.sub2 <- replicate(
  n_permutations,
  permute_tree(region_pd.SHARP_hiv.sub, tree.SHARP_hiv.sub, "ml"),
  simplify = FALSE)

# EXAMPLE - SHARP with uniform subsampling (note: not printed)
transition_counts.permuted.SHARP_hiv.sub.u <- replicate(
  n_permutations,
  permute_tree(region_pd.SHARP_hiv.sub.u, tree.SHARP_hiv.sub.u, parsimony_method = "ml"),
  simplify = FALSE) #uniform subsampling
#With uniform subsampling, we expect between-region transitions to be split evenly between coast an Nairobi (same with within-region transitions)

# EXAMPLE - risk (note: not printed)
risk_transition_counts.permuted.hiv.sub1 <- permute_tree(risk_pd.hiv.sub, tree.hiv.sub, parsimony_method = "ml")

# EXAMPLE - risk - multiple permutations (note: not printed)
risk_transition_counts.permuted.hiv.sub <- replicate(
  n_permutations,
  permute_tree(risk_pd.hiv.sub, tree.hiv.sub, parsimony_method = "ml"),
  simplify = FALSE)
```


## FUNCTION: Calculate means across multiple parsimony runs
Calculate means across the different parsimony resolutions.
```{r, mean_transitionsXparsimony function}
mean_transitionsXparsimony <- function(transition_counts = NULL, transition_sums = NULL, categories_0_1 = c(1,2)){
  #transitions_counts is a list of transition counts (the output of count_transitions or count_transitions2). The first step of the functions will be to convert these into the transitions_sums format.
  #Alternatively, transitions_sums can be provided directly. This is a matrix of transition sums, where the columns of the matrix are the permutations (resamples) and the rows are the parsimony resolutions.
  #categories: The numerical categories corresponding to the 0-1 binary comparison (for >2 category traits, each pair of traits must be calculated separately)
  
  #check that only transitions_counts OR transitions was provided
  if(!is.null(transition_sums) & !is.null(transition_counts)){
    stop("both transitions_counts and transitions were provided. The function accepts one or the other. If transition counts are provided, these will be converted to sum first")
  }
  
  if(!is.null(transition_counts)){
      transition_sums <- lapply(transition_counts, summarize_transitions, categories_0_1 = categories_0_1)
      transition_sums  <- sapply(as.data.frame(t(do.call(rbind, transition_sums))), unlist)
  }
  
  #CHECK for expected order of list names in transition_sums object
  if(!all(names(unlist(transition_sums)) ==
         c("trans_1to0_leaves", "trans_0to1_leaves", "within_1_leaves", "within_0_leaves",
           "trans_1to0", "trans_0to1", "within_1", "within_0"))){
    stop("transition_sums object does not have expected names. Expected names are (in this order): trans_1to0_leaves, trans_0to1_leaves, within_1_leaves, within_0_leaves, trans_1to0, trans_0to1, within_1, within_0")
  }
  
  
  meansXparsimony <- list( #Note: These numbers don't match up with the order of the lists in the  transition_counts object, they match with the order of the transition_sums object (all transition_counts objects are converted to transition_sums via reference to the list object names; therefore, the correct order will be maintained)
         trans_1to0_leaves = mean(transition_sums[1,]),
         trans_0to1_leaves = mean(transition_sums[2,]),
         within_1_leaves = mean(transition_sums[3,]),
         within_0_leaves = mean(transition_sums[4,]),
         trans_1to0 = mean(transition_sums[5,]),
         trans_0to1 = mean(transition_sums[6,]),
         within_1 = mean(transition_sums[7,]),
         within_0 = mean(transition_sums[8,])
  )
  
  meansXparsimony  <- sapply(as.data.frame(t(do.call(rbind, meansXparsimony))), unlist)
  
  return(meansXparsimony)
}


# EXAMPLE - SHARP
print("SHARP - Region")
mean_transitionsXparsimony(transition_counts.permuted.SHARP_hiv.sub1)

# EXAMPLE - SHARP - multiple permutations
transitions.permuted.SHARP_hiv.sub <- lapply(transition_counts.permuted.SHARP_hiv.sub2,
                                              mean_transitionsXparsimony)  %>% do.call(rbind, .) %>% t()
print("SHARP - Region (also averaged across multiple resamples / permutations)")
rowMeans(transitions.permuted.SHARP_hiv.sub)

# EXAMPLE - SHARP with uniform subsampling
transitions.permuted.SHARP_hiv.sub.u <- lapply(transition_counts.permuted.SHARP_hiv.sub.u,
                                               mean_transitionsXparsimony) %>% do.call(rbind, .) %>% t()
#With uniform subsampling, we expect between-region transitions to be split evenly between coast an Nairobi (same with within-region transitions)
print("SHARP - Region (Uniform Subsampling)")
rowMeans(transitions.permuted.SHARP_hiv.sub.u)

# EXAMPLE - risk
print("SHARP and Published - Risk")
mean_transitionsXparsimony(risk_transition_counts.permuted.hiv.sub1, categories_0_1 = c(1,3)) 

# EXAMPLE - SHARP (risk) - multiple permutations (note: not printed)
FSW_HET_transitions.permuted.hiv.sub <- lapply(risk_transition_counts.permuted.hiv.sub,
                                               mean_transitionsXparsimony, categories_0_1 = c(1,4)) %>%
  do.call(rbind, .) %>% t()
```



## FUNCTION: plot import-export counts against permutations
```{r plot_permutations function}
#plots a histogram of import or export values from permutations
plot_permutations <- function(permutation, true_value, title = "permutated number of transmission", line_name = "observed", xrange = NULL){
  #permutation = a vector or column of permutation results, true_value = the true number of imports or exports observed
  p <- ggplot(mapping = aes(permutation)) +
    geom_histogram(bins = 60, color = "black") +
    ggtitle(title) +
    geom_vline(aes(xintercept = true_value, color = "red")) +
    scale_color_manual(name = NULL, values = "red", labels = line_name) +
    theme(plot.title = element_text(size=8))
  
  if (!is.null(xrange)) {
    p <- p + xlim(xrange[1]-1, xrange[2]+1)
  }
  
  return(p)
}

# EXAMPLE - SHARP
#For 1 to 0 transitions
plot_permutations(permutation = transitions.permuted.SHARP_hiv.sub[5,, drop = TRUE],
                  true_value = mean(unlist(transitions.SHARP_hiv_sub[5,])),
                  title = "permutated number of transmissions \n Nairobi -> Coast")
```


## FUNCTION: plot all permutations
For now, this can only be used on a single tree run, so if using with down-sampled trees, pick a single down sample, or run separately on each tree in the list
```{r plot_true_vs_permutations function}
plot_true_vs_permutations <- function(transitions.df, transitions.permuted){
  #set axes
  xrange <- c(0, max(transitions.permuted, unlist(transitions.df)))
  
  observed <- apply(transitions.df, 1, function(x){mean(unlist(x))})
  
  if(is.list(transitions.permuted)){
    permutation <- sapply(as.data.frame(t(do.call(rbind, transitions.permuted))), unlist)
  } else{
    permutation <- transitions.permuted
  }
  
  transitions.plots <- vector(mode = "list", length = 12)
    #plots 1->4 are for leaf counts
    #plots 5->8 are all transitions
    #plots 9 & 10 are the fraction of between trait transitions for leaves (9) and all (10)
    #plots 11 and 12 are the ratio of 1->0 vs 0->1 transitions for leaves (11) and all (12)
  for(i in 1:8){
     p <- plot_permutations(permutation = permutation[i,],
                           true_value = observed[i],
                           title = names(observed[i]),
                           xrange = xrange)
     transitions.plots[[i]] <-p
  }
  
  

  transitions.plots[[9]] <- plot_permutations(
    permutation = (permutation[1,] + permutation[2,])/(permutation[3,] + permutation[4,]),
    true_value = (observed[1] + observed[2]) / (observed[3] + observed[4]),
    title = "Ratio between-trait vs\nwithin-trait transitions (leaves)",
    xrange = c(-0.2, 1.2))
  
    transitions.plots[[10]] <- plot_permutations(
    permutation = (permutation[5,] + permutation[6,])/(permutation[7,] + permutation[8,]),
    true_value = (observed[5] + observed[6]) / (observed[7] + observed[8]),
    title = "Ratio between-trait vs\nwithin-trait transitions (total)",
    xrange = c(-0.2, 1.2))
    
  transitions.plots[[11]] <- plot_permutations(
    permutation = (permutation[1,]/permutation[2,]),
    true_value = (observed[1]/observed[2]),
    title = "Ratio: 1->0 vs 0->1\ntransitions (leaves)")

  transitions.plots[[12]] <- plot_permutations(
    permutation = (permutation[5,]/permutation[6,]),
    true_value = (observed[5]/observed[6]),
    title = "Ratio: 1->0 vs 0->1\ntransitions (total)")

  plots <- ggpubr::ggarrange(plotlist = transitions.plots, ncol = 4, nrow = 3, common.legend = TRUE, legend = "right")

  return(plots)
}

# EXAMPLE
print("Permutations: SHARP")
example_permutation_plot <- plot_true_vs_permutations(transitions.SHARP_hiv_sub,
                                                      transitions.permuted.SHARP_hiv.sub)
print(example_permutation_plot)
```

Note: the warning about missing values is because I'm changing the x axis range to be consistent across plots and this is resulting in the rearrangement of some binds (with empty bins being dropped). I don't beleive any data is being excluded, therefore, we can ignore this warning.


## FUNCTION: Get p-value for total number of imports and exports
Also includes a function to replace 0's with very small numbers in a vector, in order to avoid dividing-by-zero errors
```{r get_p_value function}

replace0s <- function(count.vec){
  #function to replace 0s in a vector (necessary to avoid NAs for directional p-values, which is based on a ratio)
  count.vec.0replace <- min(1, ifelse(mean(count.vec)-2*sd(count.vec)<0.01, 0.01, mean(count.vec)-2*sd(count.vec))) #specifies what value to replace 0s with. Replaces 0 with whichever is lower: 1 or mean-2SD. If mean-2SD is negative, use either 0.01 instead
  count.vec <- ifelse(count.vec == 0, count.vec.0replace, count.vec)
  
  return(count.vec)
}

#CHECK
replace0s(c(1,2,4,5,0,0,0,0,2,0,3,4,5,2,6,8,2,0,5)) #replaced with 0.01
replace0s(c(51,50,50,52,0,50,50,52,51,0)) #replaced with 1
replace0s(c(51,50,50,52,0,50,40,22,31,20)) #replaced with 0.98 (based on SD)





get_p_value <- function(observed, permutations, tails = 2, H_direction = ">", scale0 = NULL){
  #H_direction: whether we expect the observed to be greater than (>) or less than (<) the null (only matters for the 1 tailed test)
  #scale0: whether to replace 0 counts with a small number (using the function replace0s())
  
  if(is.null(scale0)){ #if scale0 isn't provided, set yes for a 2-tailed test (because this is the ratio test) and no for a 1-tailed test
    scale0 <- ifelse(tails == 2, TRUE, FALSE)
  }
  
  # directional P-value, combining all subsamples
  if(scale0 == TRUE){
    observed <- replace0s(observed) #Note: observed is provided as 1 number (an average across all parsimonies), so it usually won't be 0
    permutations <- replace0s(permutations)
  }
  
  
  if(tails == 2){ P <- 2*min(sum(permutations > observed), sum(permutations < observed))/sum(permutations!=observed) } #for 2-tailed test, we have no hypothesis about expected direction of effect, so we use whichever value is more extreme, then we double the p-value to account for the possibility of either direction. We exclude permutations = observed in the denominator, as they don't count in either direction
  
  if(tails == 1 & H_direction == ">"){
    P <- sum(permutations > observed)/
         sum(permutations!=observed)  } #We expect observed values will be greater than the null, therefore, (for example, observed within-region transitions should be > than within region transitions under the null, so scenarios where )
  if(tails == 1 & H_direction == "<"){
    P <- sum(permutations < observed)/  
        sum(permutations!=observed)  } #We expect observed values will be less than than the null
  return(P)
}


# EXAMPLES - SHARP
print("P value SHARP: transitions from 1 (Nairobi) to 0 (Coast) -\n
      this is how P-values were calculated for each seperate transition count in the original summary tables.\nI'm leaving this because it's a good check, but this is not what's reported in the paper")
get_p_value(
  observed = mean(unlist(transitions.SHARP_hiv_sub[5,])),
  permutations = transitions.permuted.SHARP_hiv.sub[5,, drop = TRUE])

print("P value SHARP: transitions from 0 (Coast) to 1 (Nairobi)")
get_p_value(
  observed = mean(unlist(transitions.SHARP_hiv_sub[6,])),
  permutations = transitions.permuted.SHARP_hiv.sub[6,, drop = TRUE])

print("P value SHARP: ratio of transitions\n
      [1 (Nairobi) to 0 (Coast)]/[0 (Coast) to 1 (Nairobi)]\n
      This (ratio of 1->0 vs 0->1) is the test I used to get a P-value for directional tranmission")
get_p_value(
  observed = mean(unlist(transitions.SHARP_hiv_sub[5,])) /
    mean(unlist(transitions.SHARP_hiv_sub[6,])),
  permutations = transitions.permuted.SHARP_hiv.sub[5,, drop = TRUE] /
    transitions.permuted.SHARP_hiv.sub[6,, drop = TRUE])



print("P value SHARP: within-region transitions")
#Note: this is a 1-tailed test because we hypothesize we will observe more within-trait transitions that under the null of random trait distribution
#This is the test that is in the summary tables, but in the paper I report a ratio to scale the within-trait transition count by the total count of transitions from that trait
get_p_value(
  observed = mean(unlist(transitions.SHARP_hiv_sub[7, ])),
  permutations = transitions.permuted.SHARP_hiv.sub[7, , drop = TRUE],
  tails = 1
)


print("P value SHARP: within-region transitions\n
      [within 1 (Nairobi)] / from 1 [Nairobi to Coast]\n
      This ratio of within vs from trait (ie. Nairobi) is what I used in the paper")
#Note: this is a 1-tailed test because we hypothesize we will observe more within-trait transitions that under the null of random trait distribution
get_p_value(
  observed = 
    mean(unlist(transitions.SHARP_hiv_sub[7, ])) / #Within 1 
    mean(unlist(transitions.SHARP_hiv_sub[5, ])), #From 1
  permutations = transitions.permuted.SHARP_hiv.sub[7, , drop = TRUE] / #within 1
    transitions.permuted.SHARP_hiv.sub[5, , drop = TRUE], #From 1
  tails = 1
)


```

There were a number of reasonable ways to approach calculating P-values. In order to reduce the total number of tests, and get at the most interesting questions, this is what I settled on:  
  * Directional P-value: ratio of opposite directions: [1->0] / [0->1] transitions. (1 P value for each pair of traits). This is reported in the summary tables  
  * within-region P-value: ratio of within vs from trait: [0->0] / [0->"other"]. H(observed)>null (1 P value for each trait). IMPORTANT: because the summary tables are generated for each pair of traits, the within-group p-value is [0->0] / [0->1]; therefore, this is the within-group P value to use for a binary trait but for a trait with >2 categories, the within-group P-value must be calculted seperately.       
   
I decided this was not the most informative to report because there are a number of reasons a transition count may be higher or lower than the null (for example, within 0 transitions may be high because most 0->0 transitions are more common than 0->"other" OR within 0 transitions may be high because "other"->0 transitions are high, meaning 0 is a common ancestor state). Therefore, I decided transition ratios are more informative for evaluating trends.  

Note that the within-group p-values automatically generated in the summary tables are not ratios (they just compare the count of within-group (ex. 0->0) observed vs that same count for the null. These are NOT the within-group P-values I ended up reporting.  
  


TO DO: count / add transitions outside the functions to make the function calls cleaner and clearer  



## FUNCTION: Summary table  
transitions.df is a data frame with rows for counts of transitions:  
Nairobi_to_Coast, Coast_to_Nairobi, within_Nairobi, and within_Coast  
for leaves only (rows 1-4) and for total tree (rows 5-8)  
Columns represent results from different resolutions of parsimony (n_columns should match n_parsimony)
transitions.permuted has the same format as transitions.df, except each count is (n_columns should match n_permutations) averaged over all parsimony and the columns represent each different permutations
```{r transitions_summary_table}
transitions_summary_table <- function(meta.tree, tree, transitions.df, transitions.permuted, trait, subtype = "not provided", binary_trait = TRUE, trait_cats = NULL){
  #transitions.df is a data frame where:
    #row 1 = 0 leaves from 1 ancestors (transitions from state 1 to 0)
    #row 2 = 1 leaves from 0 ancestors (transitions from state 0 to 1),
    #row 3 = 1 leaves from 1 ancestors (within 1 "transitions")
    #row 4 = 0 leaves from 0 ancestors (within 0 "transitions")
    #rows 5-8 = Same as rows 1-4, but for full tree (not only leaves)
  #transitions.permuted is the same as transitions.df but for the permutations AND the values are already averaged over all the parsimonies
  #If binary_trait = TRUE, this code will check that all the leaves are represented in the respective trait transition counts. IMPORTANT, there is currently no corresponding check for non-binary traits
  
  #Filter metadata to match tree
  meta.tree <- meta.tree %>% filter(label %in% tree$tip.label & !is.na(source))
  
  #Define variables 0 and 1
  if(is.null(trait_cats) & (binary_trait == FALSE | length(na.omit(levels(unlist(meta.tree[, trait])))) != 2)){ #If trait is not binary, categories of interest must be provided as numbers
    stop("trait is not binary, so trait_cats (2 categories) must be provided")
  } else if(!is.null(trait_cats)){
    trait0 <- trait_cats[1] #Extract the traits
    trait1 <- trait_cats[2]
  } else {
    trait0 <- levels(unlist(meta.tree[, trait]))[1]
    trait1 <- levels(unlist(meta.tree[, trait]))[2]    
  }
  
  #print(paste0("trait0: ", trait0, " ; trait1: ", trait1)) #It would be nice to do this, but only one time per set of trees
  
  #Observed sequences from each region - N
  N_total <- length(tree$tip.label) #number of leaves
  N1 <- sum(meta.tree[, trait] ==  trait1, na.rm = TRUE)
  N0 <- sum(meta.tree[, trait] ==  trait0, na.rm = TRUE)
  
  #QC check (only works for binary traits!)
  if(binary_trait == TRUE & (transitions.df[,1]$trans_1to0_leaves + transitions.df[,1]$within_0_leaves != N0 |
     transitions.df[,1]$trans_0to1_leaves + transitions.df[,1]$within_1_leaves != N1)){
    warning("Imports to Coast and Nairobi don't sum to respective leaf counts from each region")
     }

  #Imports among leaves (ie. leaves for which the parent is a different region)
  #import leaves - N
  trait1to0_leaves <-mean(unlist(transitions.df[1,]))
  trait0to1_leaves <- mean(unlist(transitions.df[2,])) 
  within1_leaves <- mean(unlist(transitions.df[3,])) 
  within0_leaves <- mean(unlist(transitions.df[4,]))
  #import leaves - %
  trait1to0_leaves.percent <- 100*(trait1to0_leaves/N_total)
  trait0to1_leaves.percent <- 100*(trait0to1_leaves/N_total)
  within1_leaves.percent <- 100*(within1_leaves/N_total)
  within0_leaves.percent <- 100*(within0_leaves/N_total)

  #import leaves- P value (based on permutations)
  trait1to0_leaves.P <- get_p_value(trait1to0_leaves, transitions.permuted[1,])
  trait0to1_leaves.P <- get_p_value(trait0to1_leaves, transitions.permuted[2,])
  within0_leaves.P <- get_p_value(within0_leaves, transitions.permuted[3,], tails = 1)
  within1_leaves.P <- get_p_value(within1_leaves, transitions.permuted[4,], tails = 1)
  #P value for all between trait transitions in leaves
  P_within1_leaves <- get_p_value(within1_leaves/(trait1to0_leaves),
                           unlist(transitions.permuted[3,])/unlist(transitions.permuted[1,]),
                                   tails = 1, H_direction = ">") 
  P_within0_leaves <- get_p_value(within1_leaves/(trait0to1_leaves),
                           unlist(transitions.permuted[4,])/unlist(transitions.permuted[2,]),
                                   tails = 1, H_direction = ">")
  #P value for 1->0 vs 0->1 ratio in leaves
  P_0to1vs1to0_leaves <- get_p_value(trait1to0_leaves/trait0to1_leaves,
                                     unlist(transitions.permuted[1,]) / unlist(transitions.permuted[2,]))

  #Total nodes in tree (internal and external) (not included in summary table)
  N_tree <- tree$Nnode
  N_edge <- nrow(tree$edge)
  
  #Between region transmissions (transitions) in full tree
  #transitions - N
  trait1to0 <-mean(unlist(transitions.df[5,])) 
  trait0to1 <- mean(unlist(transitions.df[6,])) 
  within1 <- mean(unlist(transitions.df[7,]))
  within0 <- mean(unlist(transitions.df[8,]))
  #transitions - %
  trait1to0.percent <- 100*(trait1to0/N_edge)
  trait0to1.percent <- 100*(trait0to1/N_edge)
  within1.percent <- 100*(within1/N_edge)
  within0.percent <- 100*(within0/N_edge)
  #transitions - P value (based on permutations)
  trait1to0.P <- get_p_value(trait1to0, transitions.permuted[5,])
  trait0to1.P <- get_p_value(trait0to1, transitions.permuted[6,])
  within1.P <- get_p_value(within1, transitions.permuted[7,], tails = 1)
  within0.P <- get_p_value(within0, transitions.permuted[8,], tails = 1)
  #P value for all between regions transitions in full tree
  P_within1 <- get_p_value(within1/(trait1to0),
                           unlist(transitions.permuted[7,])/unlist(transitions.permuted[5,]),
                                   tails = 1, H_direction = ">")
  P_within0 <- get_p_value(within1/(trait0to1),
                           unlist(transitions.permuted[8,])/unlist(transitions.permuted[6,]),
                                   tails = 1, H_direction = ">")
  #P value for  1->0 vs 0->1 ratio in full tree
  P_0to1vs1to0 <- get_p_value(trait1to0/trait0to1,
                              unlist(transitions.permuted[5,]) / unlist(transitions.permuted[6,]))
  
  regional_transmissions.df <-
    data.frame(subtype = subtype,
               N_total, N1, N0,
                                          
              trait1to0_leaves, trait0to1_leaves,
              within0_leaves, within1_leaves,
              trait1to0_leaves.percent, trait0to1_leaves.percent,
              within1_leaves.percent, within0_leaves.percent,
              trait1to0_leaves.P, trait0to1_leaves.P,
              within0_leaves.P, within1_leaves.P,
              
              P_within1_leaves, P_within0_leaves, P_0to1vs1to0_leaves,
              
              N_tree, N_edge,
              
              trait1to0, trait0to1,
              within0, within1,
              trait1to0.percent, trait0to1.percent,
              within0.percent, within1.percent,
              trait1to0.P, trait0to1.P,
              within0.P, within1.P,
              
              P_within1, P_within0, P_0to1vs1to0)
  
  return(regional_transmissions.df)
}

# EXAMPLES - see next chunk (fancify_table)
```

## FUNCTION: Fancify table
```{r fancify_table function}
fancify_table <- function(summary_table, title = NULL,
                          trait0 = "?", trait1 = "?"){
  fancy_table <- summary_table %>%
    mutate(across(-c(subtype), as.numeric)) %>%
  transmute(
    "Subtype" = subtype,
    #Total observed sequences from each region:
    "Total" = N_total,
    "Trait0" = paste0(N0, " (", round(100*N0/N_total,1),"%)") ,
    "Trait1" = paste0(N1, " (", round(100*N1/N_total,1),"%)") ,
    #Imports among leaves:
    "Trait 0 to 1" = paste0(
      round(trait0to1_leaves, 0), " (",
      round(trait0to1_leaves.percent, 1), "%)\nP = ",
      signif(trait0to1_leaves.P, 2)),
    "Trait 1 to 0" = paste0(
      round(trait1to0_leaves, 0), " (",
      round(trait1to0_leaves.percent, 1), "%)\nP = ",
      signif(trait1to0_leaves.P, 2)),
    "within 1" = paste0(
      round(within1_leaves, 0), " (",
      round(within1_leaves.percent, 1), "%)\nP = ",
      signif(within1_leaves.P, 2)),
    "within 0" = paste0(
      round(within0_leaves, 0), " (",
      round(within0_leaves.percent, 1), "%)\nP = ",
      signif(within0_leaves.P, 2)),
    "within 1 P" = paste0(signif(P_within1_leaves, 2)),
    "within 0 P" = paste0(signif(P_within0_leaves, 2)),
    "ratio of 0 to 1 / 1 to 0 P" = paste0(signif(P_0to1vs1to0_leaves, 2)),
    #transition events in tree:
    "Trait 0 to 1.t" = paste0(
      round(trait0to1, 0), " (",
      round(trait0to1.percent, 1), "%)\nP = ",
      signif(trait0to1.P, 2)),
    "Trait 1 to 0.t" = paste0(
      round(trait1to0, 0), " (",
      round(trait1to0.percent, 1), "%)\nP = ",
      signif(trait1to0.P, 2)),
    "within 1.t" = paste0(
      round(within1, 0), " (",
      round(within1.percent, 1), "%)\nP = ",
      signif(within1.P, 2)),
    "within 0.t" = paste0(
      round(within0, 0), " (",
      round(within0.percent, 1), "%)\nP = ",
      signif(within0.P, 2)),
    "within 1 P.t" = paste0(signif(P_within1, 2)),
    "within 0 P.t" = paste0(signif(P_within0, 2)),
    "ratio of 0 to 1 / 1 to 0 P.t" = paste0(signif(P_0to1vs1to0, 2))
  )
  
  rownames(fancy_table) <- NULL
  
    kable(fancy_table, "html", caption = NULL) %>%
      kable_styling("striped") %>%
      add_header_above(c(" ", "N sequences (observed) " = 3, "Importations\n(for observed sequences) N (%)" = 7, "Transmissions (full tree)\nN (%)" = 7)) %>%
      footnote(paste0("observed sequences are the external nodes: sequences with known regions of origin that were used to develop the tree\n
               full tree refers to all transmissions within the tree (including between internal nodes, for which region is estimated using ancestral state reconstruction)\n
               If 3 rows are provided per transition, the first is the average over all substrees and the next 2 are the ranges (highest and lowest values observed accross all subtrees)\n
               trait 0 = ", trait0, " ; trait 1 = ", trait1))
}


# Function that will combine the tables my means
##For example, see ASR in real trees
get_subtree_means <- function(x) {
  if (is.character(unlist(x))) {
    return(as.character(unlist(x))[[1]])
  } else if (is.integer(unlist(x))) {
    return(as.integer(round(mean(as.numeric(unlist(x))))))
  } else {
    return(round(mean(as.numeric(unlist(x))), 2))
  }
}


# EXAMPLE - SHARP
transitions.SHARP_hiv.sub <- transitions_summary_table(
    meta.tree = tree.SHARP_hiv.meta,
    tree = tree.SHARP_hiv.sub,
    transitions.df = transitions.SHARP_hiv_sub,
    transitions.permuted = transitions.permuted.SHARP_hiv.sub,
    trait = "region.CN",
    subtype = "A1")
fancify_table(transitions.SHARP_hiv.sub,
              trait0 = "Coast", trait1="Nairobi") 

#EXAMPLE - SHARP with uniform subsampling
transitions.SHARP_hiv.sub.u <- transitions_summary_table(
    meta.tree = tree.SHARP_hiv.meta,
    tree = tree.SHARP_hiv.sub.u,
    transitions.df = transitions.SHARP_hiv_sub.u2,
    transitions.permuted = transitions.permuted.SHARP_hiv.sub.u,
    trait = "region.CN",
    subtype = "A1")
fancify_table(transitions.SHARP_hiv.sub.u,
              trait0 = "Coast", trait1="Nairobi")

#EXAMPLE - risk with uniform subsampling
FSW_HET_transitions.hiv.sub.u <- transitions_summary_table(meta.tree = tree.hiv.meta,
                                                           tree = tree.hiv.sub,
                          transitions.df = FSW_HET_transitions.hiv.sub,
                          transitions.permuted = FSW_HET_transitions.permuted.hiv.sub,
                          trait = "risk4.F", subtype = "A1", binary_trait = FALSE, trait_cats = c(1,4))
fancify_table(transitions.SHARP_hiv.sub.u,
              trait0 = "Coast", trait1="Nairobi")
```

TO DO: add a QC check for non-binary traits  


TO DO: Make sure set.seed() is added before all replicate() functions - ie. before resolving parsimony and resampling leaves



## FUNCTION: combine across subtrees
This takes transition tables and returns a transformed table with transition counts as the columns and rows = # resamples X number subtrees. If transitions.permuted is passes, the permutations will also all be collapsed together,s the the number of rows will be # resamples X number permutations X Number subtrees  
Not currently using?
```{r FUNCTION: combine subtree into one table}
combine_subtrees <- function(transitions.df){
  #transitions.df can be transitions or transitions.permuted
  transitions.comb <- do.call(cbind, transitions.df) %>%
    as.data.frame() %>% t()
  
  return(transitions.comb)
}
```




<br><br><br>








# COMPLETE ANCESTRAL STATE RECONSTRUCTION



# SUBTYPE A



## ML - region - SHARP PWID only - region (.1)

### Count Transitions  
Note: used rate optimization
```{r A1.1 - Count Transitions, fig.width=10, fig.height=20, eval = A1 & run1}

###

# Full tree
pd.1 <-
  phylo_variable(tree.SHARP_hiv.meta, tree.SHARP_hiv, "region.CN")

set.seed(1) #set seed before any process involving randomness (usually replicate() functions, so results are reproducible)
fit.1 <- pml(tree.SHARP_hiv, pd.1)
fit.1 <- optim.pml(fit.1, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.1 <- ancestral.pml(fit.1, "ml")
transitions.ml.1 <-
  replicate(n_parsimony,
            resolve_and_summarize_transitions(ap.1, tree.SHARP_hiv)) 

plotAnc(tree.SHARP_hiv, ap.1, cex = 0.25, show.tip.label = FALSE, main = "SHARP - Region - A1 - All seqs")

# Uniform subsampling (.u)
pd.1.u <- lapply(trees.Uniform_region_SHARP, phylo_variable, metadata = tree.SHARP_hiv.meta, trait = "region.CN")

set.seed(1)
fit.1.u <- mapply(pml, trees.Uniform_region_SHARP, pd.1.u, SIMPLIFY = FALSE)
fit.1.u <- lapply(fit.1.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.1.u <- lapply(fit.1.u , ancestral.pml, type = "ml")
transitions.ml.1.u <-
  mapply(
    function(x, y)
      replicate(n_parsimony, resolve_and_summarize_transitions(x, y)),
    ap.1.u,
    trees.Uniform_region_SHARP,
    SIMPLIFY = FALSE
  )

plotAnc(trees.Uniform_region_SHARP[[1]], ap.1.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "SHARP - Region - A1 (Uniform subsampling")


# proportionate subsampling (.p)
pd.1.p <- lapply(trees.proportionate_region_SHARP, phylo_variable, metadata =  tree.SHARP_hiv.meta, trait = "region.CN")

set.seed(1)
fit.1.p <- mapply(pml, trees.proportionate_region_SHARP, pd.1.p, SIMPLIFY = FALSE)
fit.1.p <- lapply(fit.1.p, optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.1.p <- lapply(fit.1.p, ancestral.pml, type = "ml")
transitions.ml.1.p <-
  mapply(
    function(x, y)
      replicate(n_parsimony, resolve_and_summarize_transitions(x, y)),
    ap.1.p,
    trees.proportionate_region_SHARP,
    SIMPLIFY = FALSE
  )

plotAnc(trees.proportionate_region_SHARP[[1]], ap.1.p[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "SHARP - Region - A1 (Proportionate subsampling")
```

### Run permutations 
```{r A1.1 - permutations, eval = A1 & run1}
# Full tree
set.seed(2)
transition_counts.permuted.ml.1 <-
  replicate(
    n_permutations,
    permute_tree(pd.1, tree.SHARP_hiv, "ml"),
    simplify = FALSE
  )
transitions.permuted.ml.1 <- t(do.call(rbind, lapply(transition_counts.permuted.ml.1, mean_transitionsXparsimony)))

# Uniform subsampling
set.seed(2)
transition_counts.permuted.ml.1.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.1.u,
  trees.Uniform_region_SHARP, SIMPLIFY = FALSE
)
transitions.permuted.ml.1.u <- lapply(transition_counts.permuted.ml.1.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony)))})

# Proportionate subsampling
set.seed(2)
transition_counts.permuted.ml.1.p <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.1.p,
  trees.proportionate_region_SHARP, SIMPLIFY = FALSE
)
transitions.permuted.ml.1.p <- lapply(transition_counts.permuted.ml.1.p, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony)))})
```


### Summary Table

```{r A1.1 - Summary table, eval = A1 & run1, results='asis'}

# Full tree
ml_summary.1 <- transitions_summary_table(meta.tree = tree.SHARP_hiv.meta,
                          tree = tree.SHARP_hiv,
                          transitions.df = transitions.ml.1,
                          transitions.permuted =  transitions.permuted.ml.1,
                          trait = "region.CN", subtype = "A1 (all seqs)")
fancify_table(ml_summary.1, title = "SHARP ML - all sequences", trait0 = "Coast", trait1 = "Nairobi") %T>%
  print(.) #Note saving because this isn't subsampled (it's just for QC checks)


# Uniform subsampling (.u):
ml_summary.1.u <- mapply(transitions_summary_table,
       meta.tree = rep(list(tree.SHARP_hiv.meta), n_subsamples_A1),
       tree = trees.Uniform_region_SHARP,
       transitions.df = transitions.ml.1.u,
       transitions.permuted =  transitions.permuted.ml.1.u,
       trait = "region.CN", subtype = "A1 (Uniform)") %>%
  as.data.frame() %>% t()
ml_summary_range.1.u <- apply(ml_summary.1.u, 2, range) %>% as.data.frame() #ranges across subsamples
ml_summary_mean.1.u <- apply(ml_summary.1.u, 2, get_subtree_means) %>% t() #mean across subsamples
ml_summary.comb.1.u <- rbind(ml_summary_mean.1.u, ml_summary_range.1.u) #combine mean and ranges
fancify_table(ml_summary.comb.1.u , title = "SHARP ML - uniform subsampling - range and mean",
              trait0 = "Coast", trait1 = "Nairobi") %T>% print(.) %>%
  save_kable(paste0(save_path, "A1/A1_SHARP_region_among_PWID_ASR_ml_unifrom_subsamp_SHARP_summary_table_1.html"))


# Proportionate subsampling (.p):
ml_summary.1.p <- mapply(transitions_summary_table,
       meta.tree = rep(list(tree.SHARP_hiv.meta), n_subsamples_A1.prop),
       tree = trees.proportionate_region_SHARP,
       transitions.df = transitions.ml.1.p,
       transitions.permuted =  transitions.permuted.ml.1.p,
       trait = "region.CN", subtype = "A1 (proportionate)") %>%
  as.data.frame() %>% t()
ml_summary_range.1.p <- apply(ml_summary.1.p, 2, range) %>% as.data.frame()
ml_summary_mean.1.p <- apply(ml_summary.1.p, 2, get_subtree_means) %>% t() #mean across subsamples
ml_summary.comb.1.p <- rbind(ml_summary_range.1.p, ml_summary_mean.1.p)
#Print both ranges:
fancify_table(ml_summary.comb.1.p, title = "SHARP ML - proportionate subsampling",
              trait0 = "Coast", trait1 = "Nairobi") %T>% print(.)  %>%
  save_kable(paste0(save_path, "A1/A1_SHARP_region_among_PWID_ASR_ml_proportionate_subsamp_SHARP_summary_table_1.html"))
```


#### Uniform subsampling
```{r A1.1 - save backup data - u, eval = A1 & run1 & save_backup}
saveRDS(transitions.ml.1.u, paste0(save_path, "raw_results/transitions.ml.A1.1.u.Rmd"))
saveRDS(transitions.permuted.ml.1.u, paste0(save_path, "raw_results/transitions.permuted.ml.A1.1.u.Rmd"))
saveRDS(ml_summary.1.u, paste0(save_path, "raw_results/ml_summary.1.u.Rmd"))
```

#### Proportionate
```{r A1.1 - Summary table - p, eval = A1 & run1 & run_propotionate & save_backup}
saveRDS(transitions.ml.1.p, paste0(save_path, "raw_results/transitions.ml.A1.1.p.Rmd"))
saveRDS(transitions.permuted.ml.1.p, paste0(save_path, "raw_results/transitions.permuted.ml.A1.1.p.Rmd"))
saveRDS(ml_summary.1.p, paste0(save_path, "raw_results/ml_summary.A1.1.p.Rmd"))
```



#### Illustration: different permutations
Not used in analysis: This is to visualize the tree tips, ASR probabilities for ancestor nodes, and resolved ancestor nodes assignments
```{r A1.1 - permutation illustration - u, fig.width=8, fig.height=30, eval = A1 & run1}

# Uniform Sub-sampling

### Unresolved
fit.1.u.example <- pml(trees.Uniform_region_SHARP[[1]], pd.1.u[[1]])
ap.1.u.example <- ancestral.pml(fit.1.u.example, "ml")

png(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_permutation_plots_1.png"), height = 20, width = 8, units = "in", res = 1000)
plotAnc(trees.Uniform_region_SHARP[[1]], ap.1.u.example, cex = 0.3, show.tip.label = FALSE,
        main = "SHARP - Region - A1 (Uniform, Unresolved)")
dev.off()

#Also print to screen
knitr::include_graphics(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_permutation_plots_1.png"))



### Resolved - 4 ways

png(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_permutation_resolved_plots_1.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
set.seed(1)

for(i in 1:4){
  nodestates.1.u.example <- resolve_ancestors(ap.1.u.example)
  resolved.1.u.example <- phylo_variable2(nodestates.1.u.example$nodeStates_Resolved, for_plot = TRUE)
  
  plotAnc(trees.Uniform_region_SHARP[[1]], resolved.1.u.example, cex = 0.3, show.tip.label = FALSE,
          main = "SHARP - Region - A1\n(Uniform, 4 resolutions of ancestor states")
}
dev.off()

#Also print to screen
knitr::include_graphics(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_permutation_resolved_plots_1.png"))

  
```


#### Illustration: different permutations of resample 
Not used in analysis: This is to show what the resampled trees (ie. random region assignments) look like
```{r A1.1 - resample permutation illustration - u, fig.width=10, fig.height=30, eval = A1 & run1}

set.seed(17)

# Uniform Subsampling


### Tree before ASR - not working
#layout(matrix(1:4, ncol = 1))
#set.seed(1)

for(i in 1:4){
  pd.1.u.resampled_example <- resample_trait(pd.1.u[[1]])
  pd.1.u.resampled_example.phylo <- phylo_variable2(t(as.data.frame(pd.1.u.resampled_example)), for_plot = TRUE)
  
#  plot(trees.Uniform_region_SHARP[[1]], pd.1.u.resampled_example.phylo, cex = 0.3, show.tip.label = FALSE)
}




### Unresolved - 4 different resamples

png(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_resample_permutation_plots_1.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
set.seed(1)

ap.1.u.resample_examples.list <- list()

for(i in 1:4){
  fit.1.u.resample_example <- pml(trees.Uniform_region_SHARP[[1]], pd.1.u.resampled_example)
  ap.1.u.resample_example <- ancestral.pml(fit.1.u.resample_example, "ml")
  ap.1.u.resample_examples.list <- append(ap.1.u.resample_examples.list, list(ap.1.u.resample_example))

  plotAnc(trees.Uniform_region_SHARP[[1]], ap.1.u.resample_example, cex = 0.3, show.tip.label = FALSE,
          main = "SHARP - Region - 4 Resamples -\nA1 (Uniform, Unresolved)")
}
dev.off()

#Also print to screen:
knitr::include_graphics(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_resample_permutation_plots_1.png"))




### Resolved - resolutions of the above resample (this resolves the last tree from above 4 times)
png(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_resampled_permutation_resolved_plots_1.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)


for(ap in ap.1.u.resample_examples.list){
    nodestates.1.u.resample_example <- resolve_ancestors(ap)
  resolved.1.u.resample_example <- phylo_variable2(nodestates.1.u.resample_example$nodeStates_Resolved, for_plot = TRUE)
     plotAnc(trees.Uniform_region_SHARP[[1]], resolved.1.u.resample_example, cex = 0.3, show.tip.label = FALSE,
             main = "SHARP - Region - 1 Resample -\nA1 (Uniform, resolved 4 ways)")
}
dev.off()

#Also print to screen:
knitr::include_graphics(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_resampled_permutation_resolved_plots_1.png"))





### Resolved - Resolutions of 4 different resamples
png(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_four_different_resampled_permutation_resolved_plots_1.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)

for(i in 1:4){
  pd.1.u.resampled_example <- resample_trait(pd.1.u[[1]])
  fit.1.u.resample_example <- pml(trees.Uniform_region_SHARP[[1]], pd.1.u.resampled_example)
  ap.1.u.resample_example <- ancestral.pml(fit.1.u.resample_example, "ml")
  nodestates.1.u.resample_example <- resolve_ancestors(ap.1.u.resample_example)
  resolved.1.u.resample_example <- phylo_variable2(nodestates.1.u.resample_example$nodeStates_Resolved, for_plot = TRUE)
  
  plotAnc(trees.Uniform_region_SHARP[[1]], resolved.1.u.resample_example, cex = 0.3, show.tip.label = FALSE,
          main = "SHARP - Region - 4 resamples -\nA1 (Uniform, resolved)")
}
dev.off()

#Also print to screen:
knitr::include_graphics(paste0(save_path, "examples/SHARP_region_among_PWID_ASR_ml_four_different_resampled_permutation_resolved_plots_1.png"))

par(mfrow=c(1,1)) #reset plot window

```

Notice that the nodestates tend to converge on one region as we go toward the root.  
I believe this explains why the permuted import and export counts follow a bi-modal distribution.  




### Illustration: Plot transitions counts against permutations 
#### All
```{r A1.1 - plot transitions 1, fig.width = 10, eval = write_perms & A1 & run1}
# All
transitions_plot.ml.1 <- suppressWarnings({plot_true_vs_permutations(transitions.df = transitions.ml.1,
                                                                     transitions.permuted =  transitions.permuted.ml.1)}) #CAUTION: suppressing warnings about "missing values" - this is an artifact of how I changed the x axis limits
transitions_plot.ml.1

ggsave(paste0(save_path, "A1/A1_SHARP_region_among_PWID_ASR_ml_permutations_1.png"), transitions_plot.ml.1, width = 15, height = 10, units = "in", dpi = 300)
```  

#### Uniform Subsampling
```{r A1.1 - plot transitions 2, fig.width = 10, eval = write_perms & A1 & run1}
# Uniform subsampling
transitions_plot.ml.1.u <- suppressWarnings({plot_true_vs_permutations(transitions.df = transitions.ml.1.u[[1]],
                                                                       transitions.permuted =  transitions.permuted.ml.1.u[[1]])})
transitions_plot.ml.1.u

ggsave(paste0(save_path, "A1/A1_SHARP_region_among_PWID_ASR_ml_uniform_subsamp_permtuations_1.png"), transitions_plot.ml.1.u, width = 15, height = 10, units = "in", dpi = 300)
```  

#### Proportionate Subsampling
```{r A1.1 - plot transitions 3, fig.width = 10, eval = write_perms & A1 & run1}
# Proportionate subsampling
transitions_plot.ml.1.p <-  suppressWarnings({plot_true_vs_permutations(transitions.df = transitions.ml.1.p[[1]],
                                                                        transitions.permuted =  transitions.permuted.ml.1.p[[1]])})
transitions_plot.ml.1.p 

ggsave(paste0(save_path, "A1/A1_SHARP_region_among_PWID_ASR_ml_proportionate_subsamp_permtuations_1.png"), transitions_plot.ml.1.p, width = 15, height = 10, units = "in", dpi = 300)
```  

Transition events will be high if sequences from the same region are heavily clustered.   
Because we consider only 2 regions, if sequences from one region are clustered, sequences from the other region are likely to be as well BUT this is not a guarantee because the ML parsimony method account for branch length, so it is possible that one region could show tighter clustering (shorter branches) than the other.  In this case, the difference would likely reflect differences in sampling density by region.  
We slightly more sequences from the Coast vs. Nairobi. The total number of sequences from each region should affect the underlying permuted transition counts, but I don't think it should affect the observed transition count in relation to the underlying distribution (ie. the P-value). I am not sure about this.  



### Drop objects
```{r drop A1.1 vars, eval = A1 & run1}
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
    pd.1, fit.1, ap.1,
     pd.1.u, fit.1.u, ap.1.u,
     pd.1.p, fit.1.p, ap.1.p,
     
    #transition counts - true
     transitions.ml.1, transitions.ml.1.u, transitions.ml.1.p,
    #transition counts - permuted
     transitions.permuted.ml.1, transitions.permuted.ml.1.u, transitions.permuted.ml.1.p,
     ml_summary.1, ml_summary.1.u, ml_summary.1.p,
     
    #Examples for plotting - true
     fit.1.example, ap.1.example, fit.1.u.example,
     ap.1.u.example, fit.1.p.example, ap.1.p.example,
     #Examples for plotting - permuted
     pd.1.resampled_example, pd.1.resampled_example.phylo,
     pd.1.u.resampled_example, pd.1.u.resampled_example.phylo,
     pd.1.p.resampled_example, pd.1.p.resampled_example.phylo,
     fit.1.resample_example, fit.1.u.resample_example, fit.1.p.resample_example,
     ap.1.resample_example, ap.1.resample_examples.list,
     ap.1.u.resample_example, ap.1.u.resample_examples.list,
     ap.1.p.resample_example, ap.1.p.resample_examples.list,
     nodestates.1.resample_example, nodestates.1.u.resample_example, nodestates.1.p.resample_example,
     resolved.1.resample_example, resolved.1.u.resample_example, resolved.1.p.resample_example,
    
    #plots
    transitions_plot.ml.1, transitions_plot.ml.1.u, transitions_plot.ml.1.p)})
}
```


TO DO: verify all objects are correctly dropped


<br><br>

knitr::knit_exit()


## ML - region (.2)

### Count Transitions 
Note: I have left chunks for evaluating the full (ie. not subsampled) tree (these are useful for troubleshooting, because it's a single tree, rather than a list of subsampled trees); however, I'm not running the full tree chunks because I'm only going to report results from subsampling.  
The constant "run_proportionate" defined in the setup determines whether to run the proportionately subsampled trees. I'm not planning to report results from proportionate subsampling, but may be useful to look at as I investigate why I see such different regional trends compared to prior paper (Nduva et al.) Note that the proportionately subsampled trees are also larger and required optimizing branch lengths in order to run.  
  
  
#### Full tree
```{r A1.2 - Count Transitions, fig.width=10, fig.height=30, eval = A1 & run2}

pd.2 <- phylo_variable(tree.hiv.meta, tree.hiv, "region.CN")

set.seed(1) #set seed before any process involving randomness (usually replicate() functions, so results are reproducible)
fit.2 <- pml(tree.hiv, pd.2)
fit.2 <- optim.pml(fit.2, optEdge = FALSE, optRate=TRUE, control = pml.control(trace=0)) 
fit.2 <- optim.pml(fit.2, optEdge = TRUE, optRate=FALSE,control = pml.control(trace=0), rearrangement = "none") #Also Optimize edge lengths - not ideal but otherwise we get an error!
ap.2 <- ancestral.pml(fit.2, "ml")
transitions.ml.2 <- replicate(n_parsimony, resolve_and_summarize_transitions(ap.2, unroot.phylo(tree.hiv))) 

plotAnc(unroot.phylo(tree.hiv), ap.2, cex = 0.25, show.tip.label = FALSE, main = "Region (full tree)")
```

#### Uniform subsampling (.u)
```{r A1.2 - Count Transitions - u, fig.width=10, fig.height=30, eval = A1 & run2}
pd.2.u <- lapply(trees.Uniform_region, phylo_variable, metadata =  tree.hiv.meta, trait = "region.CN")

set.seed(1)
fit.2.u <- mapply(pml, trees.Uniform_region, pd.2.u, SIMPLIFY = FALSE)
fit.2.u <- lapply(fit.2.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) #Only rate optimized (not edge length)
ap.2.u <- lapply(fit.2.u , ancestral.pml, type = "ml")
transitions.ml.2.u <-
  mapply(
    function(x, y)
      replicate(n_parsimony, resolve_and_summarize_transitions(x, y)),
    ap.2.u,
    trees.Uniform_region,
    SIMPLIFY = FALSE
  )

plotAnc(trees.Uniform_region[[1]], ap.2.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "Region (Uniform Subsampling)")
```


#### proportionate subsampling (.p)
```{r A1.2 - Count Transitions - p, fig.width=10, fig.height=30, eval = A1 & run2 & run_proportionate}
pd.2.p <- lapply(trees.proportionate_regionrisk, phylo_variable, metadata =  tree.hiv.meta, trait = "region.CN")

set.seed(1)
fit.2.p <- mapply(pml, trees.proportionate_regionrisk, pd.2.p, SIMPLIFY = FALSE)
fit.2.p <- lapply(fit.2.p, optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
fit.2.p <- lapply(fit.2.p, optim.pml, optEdge = TRUE, optRate=FALSE, 
                    control = pml.control(trace=0), rearrangement = "none") #Optimize edge lengths - not ideal but otherwise we get an error!

ap.2.p <- lapply(fit.2.p, ancestral.pml, type = "ml")
transitions.ml.2.p <-
  mapply(
    function(x, y)
      replicate(n_parsimony, resolve_and_summarize_transitions(x, y)),
    ap.2.p,
    lapply(trees.proportionate_regionrisk, unroot.phylo),
    SIMPLIFY = FALSE
  )
```

### Run permutations 
#### Full tree (NOT RUN)
```{r A1.2 - permutations (NOT WORKING - tree appears to be too large), eval = FALSE}
set.seed(2)
transition_counts.permuted.ml.2 <-
  replicate(
    n_permutations,
    permute_tree(pd.2, tree.hiv, "ml", optimize.edge = TRUE),
    simplify = FALSE
  )
transitions.permuted.ml.2 <- t(do.call(rbind, lapply(transition_counts.permuted.ml.2, mean_transitionsXparsimony)))
```


#### Uniform subsampling
```{r A1.2 - permutations - u, eval = A1 & run2}
set.seed(2)
transition_counts.permuted.ml.2.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.2.u,
  trees.Uniform_region, SIMPLIFY = FALSE
)
transitions.permuted.ml.2.u <- lapply(transition_counts.permuted.ml.2.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony)))})
```


#### Proportionate subsampling (NOT RUN)
```{r A1.2 - permutations - p (NOT WORKING - tree appears to be too large), eval = FALSE}
set.seed(2)
transition_counts.permuted.ml.2.p <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml", optimize.edge = TRUE), simplify = FALSE),
  pd.2.p,
  trees.proportionate_regionrisk, SIMPLIFY = FALSE
)
transitions.permuted.ml.2.p <- lapply(transition_counts.permuted.ml.2.p, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony)))})
```


### Summary Table
#### Full tree (NOT RUN)
```{r A1.2 - Summary table (NOT WORKING), eval = FALSE, results='asis'}
ml_summary.2 <- transitions_summary_table(meta.tree = tree.hiv.meta,
                          tree = tree.hiv,
                          transitions.df = transitions.ml.2,
                          transitions.permuted =  transitions.permuted.ml.2,
                          trait = "region.CN", subtype = "A1")
fancify_table(ml_summary.2, title = "SHARP ML - all sequences", trait0 = "Coast", trait1 = "Nairobi") %>%
  save_kable(paste0(save_path, "A1/A1_region_ASR_ml_summary_table_2.html"))
```

#### Uniform subsampling
```{r A1.2 - Summary table - u, eval = A1 & run2, results='asis'}
ml_summary.2.u <- mapply(transitions_summary_table,
       meta.tree = rep(list(tree.hiv.meta), n_subsamples_A1),
       tree = trees.Uniform_region,
       transitions.df = transitions.ml.2.u,
       transitions.permuted =  transitions.permuted.ml.2.u,
       trait = "region.CN", subtype = "A1 - region") %>%
  as.data.frame() %>% t()
ml_summary_range.2.u <- apply(ml_summary.2.u, 2, range) %>% as.data.frame()
ml_summary_mean.2.u <- apply(ml_summary.2.u, 2, get_subtree_means) %>% t() #mean across subsamples
ml_summary.comb.2.u <- rbind(ml_summary_mean.2.u, ml_summary_range.2.u)
#Print both ranges:
fancify_table(ml_summary.comb.2.u, title = "SHARP ML - uniform subsampling", trait0 = "Coast", trait1 = "Nairobi") %T>%
  print(.) %>%
  save_kable(paste0(save_path, "A1/A1_region_ASR_ml_unifrom_subsamp_summary_table_2.html"))
```

#### Proportionate subsampling (NOT RUN)
```{r A1.2 - Summary table - p (NOT WORKING), eval = FALSE, results='asis'}

ml_summary.2.p <- mapply(transitions_summary_table,
       meta.tree = rep(list(tree.hiv.meta), n_subsamples_A1.prop),
       tree = trees.proportionate,
       transitions.df = transitions.ml.2.p,
       transitions.permuted =  transitions.permuted.ml.2.p,
       trait = "region.CN", subtype = "A1") %>%
  as.data.frame() %>% t()
ml_summary_range.2.p <- apply(ml_summary.2.p, 2, range) %>%
  as.data.frame() %>% t()
ml_summary_range.2.p <- apply(ml_summary.2.p, range) %>% as.data.frame()
ml_summary_mean.2.p <- apply(ml_summary.2.p, 2, get_subtree_means) %>% t() #mean across subsamples
ml_summary.comb.2.p <- rbind(ml_summary_mean.2.p, ml_summary_range.2.p)
#Print both ranges:
fancify_table(ml_summary.comb.2.u, title = "SHARP ML - uniform subsampling", trait0 = "Coast", trait1 = "Nairobi") %T>%
  print(.) %>%
  save_kable(paste0(save_path, "A1/A1_region_ASR_ml_unifrom_subsamp_summary_table_2.html"))


```



## Save data backup

#### Uniform subsampling
```{r A1.2 - save backup data - u, eval = A1 & run2 & save_backup}
saveRDS(transitions.ml.2.u, paste0(save_path, "raw_results/transitions.ml.A1.2.u.Rmd"))
saveRDS(transitions.permuted.ml.2.u, paste0(save_path, "raw_results/transitions.permuted.ml.A1.2.u.Rmd"))
saveRDS(ml_summary.2.u, paste0(save_path, "raw_results/ml_summary.A1.2.u.Rmd"))
```

#### Proportionate subsampling
```{r A1.2 - save backup data - p, eval = A1 & run2 &run_propotionate & save_backup & FALSE}
saveRDS(transitions.ml.2.p, paste0(save_path, "raw_results/transitions.ml.A1.2.p.Rmd"))
saveRDS(transitions.permuted.ml.2.p, paste0(save_path, "raw_results/transitions.permuted.ml.A1.2.p.Rmd"))
saveRDS(ml_summary.2.p, paste0(save_path, "raw_results/ml_summary.A1.2.p.Rmd"))
```


#### Get within-group P value (For binary traits like region, this can be pulled directly from summary table and is, therefore, not needed)
Within group p-value is a ratio of transitions within the group vs all transitions from the group. Since summary table only uses the binary comparisons, we calculate this p-value separately

```{r A1.2 - p-value based on all resamples - u, eval = A1 & run2}
# Uniform subsampling  ##

### Nairobi - within group
within_p_Nairobi.u.2 <- c()

for(i in 1:n_subsamples_A1){
  withinVfrom_Nairobi.observed <- mean(unlist(transitions.ml.2.u[[i]][7,])) / 
    ( mean(unlist(transitions.ml.2.u[[i]][5,])) +
        mean(unlist(transitions.ml.2.u[[i]][5,]))  +
        mean(unlist(transitions.ml.2.u[[i]][5,])) )
  withinVfrom_Nairobi.permuted <- unlist(transitions.ml.2.u[[i]][7,]) / 
    ( unlist(transitions.ml.2.u[[i]][5,]) +
        unlist(transitions.ml.2.u[[i]][5,])  +
        unlist(transitions.ml.2.u[[i]][5,]) )
  
  within_p_Nairobi.u.2 <- append(within_p_Nairobi.u.2, get_p_value(withinVfrom_Nairobi.observed, withinVfrom_Nairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}


### Coast - within group
within_p_Coast.u.2 <- c()

for(i in 1:n_subsamples_A1){
  withinVfrom_Coast.observed <- mean(unlist(transitions.ml.2.u[[i]][8,])) / 
    ( mean(unlist(transitions.ml.2.u[[i]][6,])) +
        mean(unlist(transitions.ml.2.u[[i]][6,]))  +
        mean(unlist(transitions.ml.2.u[[i]][6,])) )
  withinVfrom_Coast.permuted <- unlist(transitions.ml.2.u[[i]][8,]) / 
    ( unlist(transitions.ml.2.u[[i]][6,]) +
        unlist(transitions.ml.2.u[[i]][6,])  +
        unlist(transitions.ml.2.u[[i]][6,]) )
  
  within_p_Coast.u.2 <- append(within_p_Coast.u.2, get_p_value(withinVfrom_Coast.observed, withinVfrom_Coast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}


### Directional

#Combine summary across subtrees
transitions.ml.2.u.comb <- matrix(do.call(cbind, transitions.ml.2.u), nrow = 8, byrow= FALSE)
transitions.permuted.ml.2.u.comb <- matrix(do.call(cbind, transitions.permuted.ml.2.u), nrow = 8, byrow= FALSE)

directional.observed <- unlist(transitions.ml.2.u.comb[8,]) /unlist(transitions.ml.2.u.comb[6,])
directional.permuted <- unlist(transitions.permuted.ml.2.u.comb[8,]) / unlist(transitions.permuted.ml.2.u.comb[6,])
  
directional_p.u.2 <- get_p_value(directional.observed, directional.permuted , tails = 2, scale0 = TRUE)




### Print
p_values.u.2 <- paste("Within vs from Nairobi (averaged): ", round(mean(within_p_Nairobi.u.2), 3),
      "\nWithin vs from Coast (Averaged): ", round(mean(within_p_Coast.u.2), 3),
      "\nDirectional (Combined): ", round(directional_p.u.2, 3))
cat(p_values.u.2) #Print


### Save All ##
cat(p_values.u.2, file = paste0(save_path, "A1/A1_region_ASR_ml_uniform.2.p_value.txt"))






## Proportionate subsampling ##


### Nairobi
within_p_Nairobi.p.2 <- c()

for(i in 1:n_subsamples_A1){
  withinVfrom_Nairobi.observed <- mean(unlist(transitions.ml.2.p[[i]][7,])) / 
    ( mean(unlist(transitions.ml.2.p[[i]][5,])) +
        mean(unlist(transitions.ml.2.p[[i]][5,]))  +
        mean(unlist(transitions.ml.2.p[[i]][5,])) )
  withinVfrom_Nairobi.permuted <- unlist(transitions.ml.2.p[[i]][7,]) / 
    ( unlist(transitions.ml.2.p[[i]][5,]) +
        unlist(transitions.ml.2.p[[i]][5,])  +
        unlist(transitions.ml.2.p[[i]][5,]) )
  
  within_p_Nairobi.p.2 <- append(within_p_Nairobi.p.2, get_p_value(withinVfrom_Nairobi.observed, withinVfrom_Nairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}


### Coast
within_p_Coast.p.2 <- c()

for(i in 1:n_subsamples_A1){
  withinVfrom_Coast.observed <- mean(unlist(transitions.ml.2.p[[i]][8,])) / 
    ( mean(unlist(transitions.ml.2.p[[i]][6,])) +
        mean(unlist(transitions.ml.2.p[[i]][6,]))  +
        mean(unlist(transitions.ml.2.p[[i]][6,])) )
  withinVfrom_Coast.permuted <- unlist(transitions.ml.2.p[[i]][8,]) / 
    ( unlist(transitions.ml.2.p[[i]][6,]) +
        unlist(transitions.ml.2.p[[i]][6,])  +
        unlist(transitions.ml.2.p[[i]][6,]) )
  
  within_p_Coast.p.2 <- append(within_p_Coast.p.2, get_p_value(withinVfrom_Coast.observed, withinVfrom_Coast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

### Print
p_values.p.2 <- paste("\nWithin vs from Nairobi (Averaged): ", round(mean(within_p_Nairobi.p.2), 3),
      "\nWithin vs from Coast (Averaged): ", round(mean(within_p_Coast.p.2), 3))
cat(p_values.p.2) #Print





## Save All ##
cat(p_values.p.2, file = paste0(save_path, "A1/A1_region_ASR_ml_proportionate.2.p_value.txt"))


```




#### Illustration: different permutations
Not used in analysis: This is to show what the resampled trees (ie. random region assignments) look like
```{r A1.2 - permutation illustration - u, fig.width=10, fig.height=30, eval = A1 & run2}
# Uniform Subsampling
png(paste0(save_path, "A1/A1_region_ASR_ml_uniform_subsamp_permutation_plots_2.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)

for(i in 1:4){
  pd.2.u.resampled_example <- resample_trait(pd.2.u[[1]])
  fit.2.u.resample_example <- pml(trees.Uniform_region[[1]], pd.2.u.resampled_example)
  ap.2.u.resample_example <- ancestral.pml(fit.2.u.resample_example, "ml")
  
  plotAnc(trees.Uniform_region[[1]], ap.2.u.resample_example, cex = 0.3, show.tip.label = FALSE)
}

dev.off()
#Also print to screen
knitr::include_graphics(paste0(save_path, "A1/A1_region_ASR_ml_uniform_subsamp_permutation_plots_2.png"))

par(mfrow=c(1,1))
```



### Illustration: Plot transitions counts against permutations
Not used in analysis
```{r A1.2 - plot transitions - u & p, fig.width = 10, eval = write_perms & A1 & run2}
# Uniform subsampling
transitions_plot.ml.2.u <- plot_true_vs_permutations(transitions.df = transitions.ml.2.u[[1]], transitions.permuted =  transitions.permuted.ml.2.u[[1]])
transitions_plot.ml.2.u 

ggsave(paste0(save_path, "A1/A1_region_ASR_ml_uniform_subsamp_permutations_2.png"), transitions_plot.ml.2.u, width = 15, height = 10, units = "in", dpi = 300)
```  


### Drop objects
```{r drop A1.2 vars, eval = A1 & run2}
if(drop_ASR == TRUE){
  suppressWarnings(rm(
    #ASR objects
    pd.2, fit.2, ap.2,
     pd.2.u, fit.2.u, ap.2.u,
     pd.2.p, fit.2.p, ap.2.p,
     
    #transition counts - true
     transitions.ml.2, transitions.ml.2.u, transitions.ml.2.p,
    #transition counts - permuted
     transitions.permuted.ml.2, transitions.permuted.ml.2.u, transitions.permuted.ml.2.p,
     ml_summary.2, ml_summary.2.u, ml_summary.2.p,
     
    #Examples for plotting - true
     fit.2.example, ap.2.example, fit.2.u.example,
     ap.2.u.example, fit.2.p.example, ap.2.p.example,
     #Examples for plotting - permuted
     pd.2.resampled_example, pd.2.resampled_example.phylo,
     pd.2.u.resampled_example, pd.2.u.resampled_example.phylo,
     pd.2.p.resampled_example, pd.2.p.resampled_example.phylo,
     fit.2.resample_example, fit.2.u.resample_example, fit.2.p.resample_example,
     ap.2.resample_example, ap.2.resample_examples.list,
     ap.2.u.resample_example, ap.2.u.resample_examples.list,
     ap.2.p.resample_example, ap.2.p.resample_examples.list,
     nodestates.2.resample_example, nodestates.2.u.resample_example, nodestates.2.p.resample_example,
     resolved.2.resample_example, resolved.2.u.resample_example, resolved.2.p.resample_example,
    
    #plots
    transitions_plot.ml.2, transitions_plot.ml.2.u, transitions_plot.ml.2.p))
}
```



<br><br><br>




## ML - risk (.3)
What are refered to as "risk" categories here, will be refered to as "population" in the write-up  
Populations:  
  * FSW: female sex workers  
  * HET: not in a key population (this population is often refereed to as "heterosexual" in the literature, which is why it's abbreviated "HET" here; however, in write-ups I will use "not-KP" for "not in a key population")  
  * MSM: men who have sex with men  
  * PWID: people who inject drugs  

For risk / population, I only plan to report uniform subsampling (maybe remove proportionate subsampling all together?)   

### Count transitions
#### unifrom subsampling (.u)
```{r A1.3 - Count Transitions - u, fig.width=10, fig.height=30, eval = A1 & run3}
pd.3.u <- lapply(trees.Uniform_risk, phylo_variable, metadata =  tree.hiv.meta, trait = "risk4.F")

set.seed(1)
fit.3.u <- mapply(pml, trees.Uniform_risk, pd.3.u, SIMPLIFY = FALSE)
fit.3.u <- lapply(fit.3.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.3.u <- lapply(fit.3.u , ancestral.pml, type = "ml")
nodestates.ml.3.u <- lapply(ap.3.u, function(x) replicate(n_parsimony, resolve_ancestors(x, only_resolved = TRUE), simplify = FALSE))
ap.3.u #CHECK site patterns (these should be alphabetical!)

transition_counts.ml.3.u <- mapply(function(x,y){
    lapply(x, function(z) { count_transitions2(z, tree = y)})
  }, nodestates.ml.3.u, trees.Uniform_risk, SIMPLIFY = FALSE)

#Get counts for different pairs of populations
transitions.ml.3.u_FSW_PWID <- lapply(transition_counts.ml.3.u, function(x){ #
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,4))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.3.u_HET_PWID <- lapply(transition_counts.ml.3.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,4))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.3.u_MSM_PWID <- lapply(transition_counts.ml.3.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))


plotAnc(trees.Uniform_risk[[1]], ap.3.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "Risk (Uniform Subsampling)")
```


#### Proportionate subsampling (.p)
```{r A1.3 - Count Transitions - p, fig.width=10, fig.height=30, eval = FALSE}

pd.3.p <- lapply(trees.proportionate_regionrisk, phylo_variable, metadata =  tree.hiv.meta, trait = "risk4.F")

set.seed(1)
fit.3.p <- mapply(pml, trees.proportionate_regionrisk, pd.3.p, SIMPLIFY = FALSE)
fit.3.p <- lapply(fit.3.p , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.3.p <- lapply(fit.3.p , ancestral.pml, type = "ml")
nodestates.ml.3.p <- lapply(ap.3.p, function(x) replicate(n_parsimony, resolve_ancestors(x, only_resolved = TRUE), simplify = FALSE))
ap.3.p #CHECK site patterns (these should be alphabetical!)

transition_counts.ml.3.p <- mapply(function(x,y){
    lapply(x, function(z) { count_transitions2(z, tree = y)})
  }, nodestates.ml.3.p, trees.proportionate_regionrisk, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.ml.3.p_FSW_PWID <- lapply(transition_counts.ml.3.p, function(x){ #
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,4))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.3.p_HET_PWID <- lapply(transition_counts.ml.3.p, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,4))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.3.p_MSM_PWID <- lapply(transition_counts.ml.3.p, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))


plotAnc(trees.proportionate_regionrisk[[1]], ap.3.p[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "Risk (Proportionate Subsampling)")
```

^If you run this, the resulting plot shows why proportionate subsampling is not very meaningful with such different group sizes: of course the tree quickly converges towards the HET trait.


### Run permutations

```{r A1.3 - permutations - u, eval = A1 & run3}
# Uniform subsampling
set.seed(2)
transition_counts.permuted.ml.3.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml", optimize = TRUE), simplify = FALSE),
  pd.3.u,
  trees.Uniform_risk, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.permuted.ml.3.u_FSW_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,4))))})
transitions.permuted.ml.3.u_HET_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,4))))})
transitions.permuted.ml.3.u_MSM_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(3,4))))})
```

```{r A1.3 - permutations - p, eval = FALSE}
# Proportionate subsampling
set.seed(2)
transition_counts.permuted.ml.3.p <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml", optimize.edge = TRUE), simplify = FALSE),
  pd.3.p,
  lapply(trees.proportionate_regionrisk, unroot.phylo), SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.permuted.ml.3.p_FSW_PWID <- lapply(transition_counts.permuted.ml.3.p, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,4))))})
transitions.permuted.ml.3.p_HET_PWID <- lapply(transition_counts.permuted.ml.3.p, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,4))))})
transitions.permuted.ml.3.p_MSM_PWID <- lapply(transition_counts.permuted.ml.3.p, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(3,4))))})
```


### Summary Table

#### Uniform Subsampling
```{r A1.3 - Summary table - u, eval = A1 & run3, results='asis'}
ml_summary.3.u_FSW_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_FSW_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_FSW_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("FSW", "PWID"), subtype = "A1 - FSW&PWID",  binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_FSW_PWID <- apply(ml_summary.3.u_FSW_PWID, 2, range) %>% as.data.frame
ml_summary.3.u_FSW_PWID <- apply(ml_summary.3.u_FSW_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_FSW_PWID) #add mean

ml_summary.3.u_HET_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_HET_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_HET_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("HET", "PWID"),
                       subtype = "A1 - HET&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_HET_PWID <- apply(ml_summary.3.u_HET_PWID, 2, range) %>% as.data.frame #range
ml_summary.3.u_HET_PWID <- apply(ml_summary.3.u_HET_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_HET_PWID) #add mean

ml_summary.3.u_MSM_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_MSM_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_MSM_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("MSM", "PWID"),
                       subtype = "A1 - MSM&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_MSM_PWID <- apply(ml_summary.3.u_MSM_PWID, 2, range) %>% as.data.frame #range
ml_summary.3.u_MSM_PWID <- apply(ml_summary.3.u_MSM_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_MSM_PWID) #add mean



# Combine into 1 table
ml_summary.3.u <- rbind(ml_summary.3.u_FSW_PWID, ml_summary.3.u_HET_PWID) %>%
  rbind(ml_summary.3.u_MSM_PWID)

#Print fancy table:
fancify_table(ml_summary.3.u, title = "SHARP ML - uniform subsampling", trait0 = "FSW, HET, MSM", trait1 = "PWID, PWID, PWID") %T>% print(.) %>%
  save_kable(paste0(save_path, "A1/A1_risk_ASR_ml_uniform_summary_table_3.html"))
```


#### Proportionate Subsampling
```{r A1.3 - Summary table - p, eval = FALSE, results='asis'}
ml_summary.3.p_FSW_PWID <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk,
       transitions.df = transitions.ml.3.p_FSW_PWID,
       transitions.permuted =  transitions.permuted.ml.3.p_FSW_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("FSW", "PWID"),
                       subtype = "A1 - FSW&PWID",  binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.p_FSW_PWID <- apply(ml_summary.3.p_FSW_PWID, 2, range) %>%
  as.data.frame #range
ml_summary.3.p_FSW_PWID <- apply(ml_summary.3.p_FSW_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.p_FSW_PWID) # add mean

ml_summary.3.p_HET_PWID <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk,
       transitions.df = transitions.ml.3.p_HET_PWID,
       transitions.permuted =  transitions.permuted.ml.3.p_HET_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("HET", "PWID"),
                       subtype = "A1 - HET&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.p_HET_PWID <- apply(ml_summary.3.p_HET_PWID, 2, range) %>%  as.data.frame() # range
ml_summary.3.p_HET_PWID <- apply(ml_summary.3.p_HET_PWID , 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.p_HET_PWID) # add mean

ml_summary.3.p_MSM_PWID <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk,
       transitions.df = transitions.ml.3.p_MSM_PWID,
       transitions.permuted =  transitions.permuted.ml.3.p_MSM_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("MSM", "PWID"),
                       subtype = "A1 - MSM&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.p_MSM_PWID <- apply(ml_summary.3.p_MSM_PWID , 2, range) %>% as.data.frame() # range
ml_summary.3.p_MSM_PWID <- apply(ml_summary.3.p_MSM_PWID , 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.p_MSM_PWID) # add mean



# Combine into 1 table
ml_summary.3.p <- rbind(ml_summary.3.p_FSW_PWID, ml_summary.3.p_HET_PWID) %>%
  rbind(ml_summary.3.p_MSM_PWID)

#Print fancy table:
fancify_table(ml_summary.3.p, title = "SHARP ML - proportionate subsampling", trait0 = "FSW, HET, MSM", trait1 = "PWID, PWID, PWID") %T>% print(.) %>%
  save_kable(paste0(save_path, "A1/A1_risk_ASR_ml_proportionate_summary_table_3.html"))
```


### Save Raw result Data
#### Uniform subsampling
```{r A1.3 - save backup data - u, eval = A1 & run3 & save_backup}
saveRDS(transition_counts.ml.3.u, paste0(save_path, "raw_results/transition_counts.ml.A1.3.u.Rmd"))
saveRDS(transition_counts.permuted.ml.3.u, paste0(save_path, "raw_results/transition_counts.permuted.ml.A1.3.u.Rmd"))

saveRDS(ml_summary.3.u_FSW_PWID, paste0(save_path, "raw_results/ml_summary.A1.3.u_FSW_PWID.Rmd"))
saveRDS(ml_summary.3.u_MSM_PWID, paste0(save_path, "raw_results/ml_summary.A1.3.u_MSM_PWID.Rmd"))
saveRDS(ml_summary.3.u_HET_PWID, paste0(save_path, "raw_results/ml_summary.A1.3.u_HET_PWID.Rmd"))

```

#### Proportionate
```{r A1.3 - save backup data - p, eval = FALSE}
saveRDS(transition_counts.ml.3.p, paste0(save_path, "raw_results/transition_counts.ml.A1.3.p.Rmd"))
saveRDS(transition_counts.permuted.ml.3.p, paste0(save_path, "raw_results/transition_counts.permuted.ml.A1.3.p.Rmd"))

saveRDS(ml_summary.3.p_FSW_PWID, paste0(save_path, "raw_results/ml_summary.A1.3.p_FSW_PWID.Rmd"))
saveRDS(ml_summary.3.p_MSM_PWID, paste0(save_path, "raw_results/ml_summary.A1.3.p_MSM_PWID.Rmd"))
saveRDS(ml_summary.3.p_HET_PWID, paste0(save_path, "raw_results/ml_summary.A1.3.p_HET_PWID.Rmd"))
```


#### Get within-group P value
Within group p-value is a ratio of transitions within the group vs all transitions from the group. Since summary table only uses the binary comparisons, we calculate this p-value separately

```{r A1.3 - P-value based on all resamples - u, eval = A1 & run3}
# Within trait
### PWID (average over subtrees)
within_p_PWID.u.3 <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_PWID.observed <- mean(unlist(transitions.ml.3.u_MSM_PWID[[i]][7,])) / 
    ( mean(unlist(transitions.ml.3.u_MSM_PWID[[i]][5,])) +
        mean(unlist(transitions.ml.3.u_FSW_PWID[[i]][5,]))  +
        mean(unlist(transitions.ml.3.u_HET_PWID[[i]][5,])) )
  withinVfrom_PWID.permuted <- unlist(transitions.permuted.ml.3.u_MSM_PWID[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID[[i]][5,]) +
        unlist(transitions.permuted.ml.3.u_FSW_PWID[[i]][5,])  +
        unlist(transitions.permuted.ml.3.u_HET_PWID[[i]][5,]) )
  
  within_p_PWID.u.3 <- append(within_p_PWID.u.3, get_p_value(withinVfrom_PWID.observed, withinVfrom_PWID.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

withinPWID_PValue.averaged <- paste("Within vs from PWID (averaged): ", round(mean(within_p_PWID.u.3), 3))
withinPWID_PValue.averaged 


### PWID (combine subtrees & calc 1 p-value)

#Combine across subtrees
transitions.ml.3.u_MSM_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_MSM_PWID), nrow = 8, byrow= FALSE)
#do.call(cbind, lapply(transitions.ml.3.u_FSW_PWID, as.data.frame))
transitions.ml.3.u_FSW_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_FSW_PWID), nrow = 8, byrow= FALSE)
transitions.ml.3.u_HET_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_HET_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_MSM_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_MSM_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_FSW_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_FSW_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_HET_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_HET_PWID), nrow = 8, byrow= FALSE)

#Get P-value
  withinVfrom_PWID.observed.comb <- mean(unlist(transitions.ml.3.u_MSM_PWID.comb[7,])) / 
    ( mean(unlist(transitions.ml.3.u_MSM_PWID.comb[5,])) +
        mean(unlist(transitions.ml.3.u_FSW_PWID.comb[5,]))  +
        mean(unlist(transitions.ml.3.u_HET_PWID.comb[5,])) )
  withinVfrom_PWID.permuted.comb <- unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[7,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[5,]) +
        unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[5,])  +
        unlist(transitions.permuted.ml.3.u_HET_PWID.comb[5,]) )
  within_p_PWID.u.3 <- get_p_value(withinVfrom_PWID.observed.comb,
                                   withinVfrom_PWID.permuted.comb, tails = 1, H_direction = ">", scale0 = TRUE)


withinPWID_PValue.combined <- paste("Within vs from PWID (combined): ", round(mean(within_p_PWID.u.3), 3))
withinPWID_PValue.combined  
withinPWID_PValue <- paste(withinPWID_PValue.averaged, "\n", withinPWID_PValue.combined)
cat(withinPWID_PValue, file=paste0(save_path, "A1/A1_risk_ASR_ml_uniform.3.p_value.txt"))





# Between trait
### PWID & FSW (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_FSW.observed.comb <- mean(unlist(transitions.ml.3.u_FSW_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_FSW_PWID.comb[6,]))
  directional_PWID_FSW.permuted.comb <- unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[6,]))
  directional_p_PWID_FSW.u.3 <- get_p_value(directional_PWID_FSW.observed.comb,
                                   directional_PWID_FSW.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_FSW.combined <- paste("Directional (PWID & FSW), combined: ", round(mean(directional_p_PWID_FSW.u.3), 3))
directional_PWID_FSW.combined


### PWID & MSM (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_MSM.observed.comb <- mean(unlist(transitions.ml.3.u_MSM_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_MSM_PWID.comb[6,]))
  directional_PWID_MSM.permuted.comb <- unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[6,]))
  directional_p_PWID_MSM.u.3 <- get_p_value(directional_PWID_MSM.observed.comb,
                                   directional_PWID_MSM.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_MSM.combined <- paste("Directional (PWID & MSM), combined: ", round(mean(directional_p_PWID_MSM.u.3), 3))
directional_PWID_MSM.combined


### PWID & HET (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_HET.observed.comb <- mean(unlist(transitions.ml.3.u_HET_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_HET_PWID.comb[6,]))
  directional_PWID_HET.permuted.comb <- unlist(transitions.permuted.ml.3.u_HET_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_HET_PWID.comb[6,]))
  directional_p_PWID_HET.u.3 <- get_p_value(directional_PWID_HET.observed.comb,
                                   directional_PWID_HET.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_HET.combined <- paste("Directional (PWID & HET), combined: ", round(mean(directional_p_PWID_HET.u.3), 3))
directional_PWID_HET.combined





## Save all ##
risk_PValue <- paste(withinPWID_PValue.averaged, "\n", withinPWID_PValue.combined, "\n",
                     directional_PWID_MSM.combined, "\n", directional_PWID_MSM.combined, "\n", directional_PWID_HET.combined)
cat(risk_PValue, file=paste0(save_path, "A1/A1_risk_ASR_ml_uniform.3.p_value.txt"))

```

TO DO: Calculate for the other 3 traits? (this will involved counting the transitions between those traits, which I haven't done yet because I was only focusing on PWID).



#### Illustration: different permutations 
Not used in analysis: This is to show what the resampled trees (ie. random region assignments) look like
```{r , A1.3 permutation illustration - u, fig.width=10, fig.height=30, eval = A1 & run3 & write_perms}
# Uniform subsampling
png(paste0(save_path, "A1/A1_risk_ASR_ml_uniform_subsamp_permutation_plots_3.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)

for(i in 1:4){
  pd.3.u.resampled_example <- resample_trait(pd.3.u[[1]])
  fit.3.u.resample_example <- pml(trees.Uniform_risk[[1]], pd.3.u.resampled_example)
  ap.3.u.resample_example <- ancestral.pml(fit.3.u.resample_example, "ml")
  
  plotAnc(trees.Uniform_risk[[1]], ap.3.u.resample_example, cex = 0.3, show.tip.label = FALSE,
          main = "Risk Population - Resampled Tips (Uniform Subsampling)")
}

dev.off()
#Also print to screen
knitr::include_graphics(paste0(save_path, "A1/A1_risk_ASR_ml_uniform_subsamp_permutation_plots_3.png"))

par(mfrow=c(1,1))
```
Notice that the nodestates tend to converge on one region as we go toward the root.  
I believe this explains why the permuted import and export counts follow a bi-modal distribution.  


### Illustration: Plot transitions counts against permutations   
Not used in analysis
```{r A1.3 - plot transitions - u, fig.width = 10, eval = write_perms & A1 & run3}

# Uniform subsampling - HET and PWID
transitions_plot.ml.3.u_HET_PWID <- suppressWarnings({plot_true_vs_permutations(
  transitions.df = transitions.ml.3.u_HET_PWID[[1]],
  transitions.permuted =  transitions.permuted.ml.3.u_HET_PWID[[1]])})
transitions_plot.ml.3.u_HET_PWID

ggsave(paste0(save_path, "A1/A1_risk_ASR_ml_uniform_subsamp_permtuations_3.png"), transitions_plot.ml.3.u_HET_PWID, width = 15, height = 10, units = "in", dpi = 300)
```  


### Drop objects
```{r drop A1.3 vars, eval = A1 & run3}
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
    pd.3, fit.3, ap.3,
     pd.3.u, fit.3.u, ap.3.u,
     pd.3.p, fit.3.p, ap.3.p,
     
    #transition counts - true
     transitions.ml.3, transitions.ml.3.u, transitions.ml.3.p,
    #transition counts - permuted
     transitions.permuted.ml.3, transitions.permuted.ml.3.u, transitions.permuted.ml.3.p,
     ml_summary.3, ml_summary.3.u, ml_summary.3.p,
     
    #Examples for plotting - true
     fit.3.example, ap.3.example, fit.3.u.example,
     ap.3.u.example, fit.3.p.example, ap.3.p.example,
     #Examples for plotting - permuted
     pd.3.resampled_example, pd.3.resampled_example.phylo,
     pd.3.u.resampled_example, pd.3.u.resampled_example.phylo,
     pd.3.p.resampled_example, pd.3.p.resampled_example.phylo,
     fit.3.resample_example, fit.3.u.resample_example, fit.3.p.resample_example,
     ap.3.resample_example, ap.3.resample_examples.list,
     ap.3.u.resample_example, ap.3.u.resample_examples.list,
     ap.3.p.resample_example, ap.3.p.resample_examples.list,
     nodestates.3.resample_example, nodestates.3.u.resample_example, nodestates.3.p.resample_example,
     resolved.3.resample_example, resolved.3.u.resample_example, resolved.3.p.resample_example,
    
    #plots
    transitions_plot.ml.3, transitions_plot.ml.3.u, transitions_plot.ml.3.p,
    
    #P-values
    withinVfrom_PWID.observed, withinVfrom_PWID.permuted, within_p_PWID.u.3)})
}
```




<br><br><br>




## ML - risk & region combined - Uniform subsampling(.4)  
Note: to save computational space, I ran all of uniform subsampling then dropped these objects and ran all of proportionate sub sampling (for the other ASR types, they're combined OR, in some cases, proportionate subsampling was not done). I'm not plannign to report results from proportioante subsampling here, as I don't think they're informative

### Count Transitions
```{r A1.4 - Count Transitions - u, fig.width=10, fig.height=30, eval = A1 & run4}

# Uniform subsampling (.u)
pd.4.u <- lapply(trees.Uniform_riskregion, phylo_variable, metadata =  tree.hiv.meta, trait = "PWID_region.comb")

set.seed(1)
fit.4.u <- mapply(pml, trees.Uniform_riskregion, pd.4.u, SIMPLIFY = FALSE)
fit.4.u <- lapply(fit.4.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.4.u <- lapply(fit.4.u , ancestral.pml, type = "ml")
nodestates.ml.4.u <- lapply(ap.4.u, function(x) replicate(n_parsimony, resolve_ancestors(x, only_resolved = TRUE), simplify = FALSE))
ap.4.u[[1]] #CHECK site patterns (these should be alphabetical!)

transition_counts.ml.4.u <- mapply(function(x,y){
    lapply(x, function(z) { count_transitions2(z, tree = y)})
  }, nodestates.ml.4.u, trees.Uniform_riskregion, SIMPLIFY = FALSE)


# Get counts for different pairs of key pops
transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){ #
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,2))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDCoast_PWIDCoast <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,3))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDCoast_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,4))})
  
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDNairobi_PWIDCoast <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,3))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,4))})
  
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_PWIDCoast_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))


#Visualize tree
plotAnc(trees.Uniform_riskregion[[1]], ap.4.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "PWID&Region combined (Uniform Subsampling)")
```

### Run permutations 
```{r A1.4 - permutations - u, eval = A1 & run4}

# Uniform subsampling
set.seed(2)
transition_counts.permuted.ml.4.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.4.u,
  trees.Uniform_riskregion, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,2))))})
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,3))))})
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,4))))})

transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,3))))})
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,4))))})

transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(3,4))))})
```


### Summary Table

```{r A1.4 - Summary table - u, eval = A1 & run4, results='asis'}

# Uniform subsampling:

##initialize and empty data frame to hold the transition counts between each group (for total tree)
riskregion.transitioncounts.u <- matrix(ncol = 4, nrow = 4)
colnames(riskregion.transitioncounts.u) <- c("nonPWIDCoast", "nonPWIDNairobi", "PWIDCoast", "PWIDNairobi")
rownames(riskregion.transitioncounts.u) <- c("nonPWIDCoast", "nonPWIDNairobi", "PWIDCoast", "PWIDNairobi")
#In the matrix, FROM is the column names and TO is the row names - verify this!

ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "nonPWID_Nairobi"), subtype = "A1 - nonPWIDCoast&nonPWIDNairobi",
                       binary_trait = FALSE)) %>%
  data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_nonPWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDCoast_nonPWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_nonPWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["nonPWIDNairobi", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$trait1to0))
riskregion.transitioncounts.u["nonPWIDCoast", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$within0)) #Also for within nonPWIDCoast
riskregion.transitioncounts.u["nonPWIDNairobi", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$within1)) #Also for within nonPWIDNairobi


ml_summary.4.u_nonPWIDCoast_PWIDCoast <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_PWIDCoast,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "PWID_Coast"), subtype = "A1 - nonPWIDCoast&PWIDCoast",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_PWIDCoast <- apply(ml_summary.4.u_nonPWIDCoast_PWIDCoast, 2, range) %>%
  as.data.frame()  # range
ml_summary_comb.4.u_nonPWIDCoast_PWIDCoast <- apply(ml_summary.4.u_nonPWIDCoast_PWIDCoast, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_PWIDCoast) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDCoast", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$trait1to0))
riskregion.transitioncounts.u["PWIDCoast", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$within1)) #also for within PWIDCoast


ml_summary.4.u_nonPWIDCoast_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "PWID_Nairobi"), subtype = "A1 - nonPWIDCoast&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$trait1to0))
riskregion.transitioncounts.u["PWIDNairobi", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$within1)) #also for within PWIDNairobi

ml_summary.4.u_nonPWIDNairobi_PWIDCoast <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDNairobi_PWIDCoast,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Nairobi", "PWID_Coast"), subtype = "A1 - nonPWIDNairobi&PWIDCoast",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDNairobi_PWIDCoast <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDNairobi_PWIDCoast <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDNairobi_PWIDCoast) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDCoast", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDCoast$trait0to1))
riskregion.transitioncounts.u["nonPWIDNairobi", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDCoast$trait1to0))

ml_summary.4.u_nonPWIDNairobi_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Nairobi", "PWID_Nairobi"), subtype = "A1- nonPWIDNairobi&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDNairobi_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDNairobi_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDNairobi_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDNairobi", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi$trait1to0))

ml_summary.4.u_PWIDCoast_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_PWIDCoast_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("PWID_Coast", "PWID_Nairobi"), subtype = "A1 - PWIDCoast&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_PWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_PWIDCoast_PWIDNairobi, 2, range) %>%
  as.data.frame() # range
ml_summary_comb.4.u_PWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_PWIDCoast_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_PWIDCoast_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_PWIDCoast_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["PWIDCoast", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_PWIDCoast_PWIDNairobi$trait1to0))


# Combine into 1 table
ml_summary.4.u <- rbind(ml_summary_comb.4.u_nonPWIDCoast_nonPWIDNairobi,
                              ml_summary_comb.4.u_nonPWIDCoast_PWIDCoast) %>%
  rbind(ml_summary_comb.4.u_nonPWIDCoast_PWIDNairobi) %>%
  rbind(ml_summary_comb.4.u_nonPWIDNairobi_PWIDCoast) %>%
  rbind(ml_summary_comb.4.u_nonPWIDNairobi_PWIDNairobi) %>%
  rbind(ml_summary_comb.4.u_PWIDCoast_PWIDNairobi)

#Print fancy table:
fancify_table(ml_summary.4.u, title = "SHARP ML - uniform subsampling", trait0 = "nonPWID_Coast, nonPWID_Coast, nonPWID_Coast, nonPWID_Nairobi, nonPWID_Nairobi, PWIDCoast", trait1 = "nonPWID_Nairobi, PWID_Coast, PWID_Nairobi, PWID_Coast, PWID_Nairobi, PWID_Nairobi") %T>% print(.) %>%
  save_kable(paste0(save_path, "A1/A1_PWIDxregion_ASR_ml_uniform_nonPWIDCoast_PWIDCoast_summary_table_4.html"))
```



### Save Raw Result Data
```{r A1.4 - save backup data - u, eval = A1 & run4 & save_backup}
saveRDS(transition_counts.ml.4.u, paste0(save_path, "raw_results/transition_counts.ml.A1.4.u.Rmd"))
saveRDS(transition_counts.permuted.ml.4.u, paste0(save_path, "raw_results/transition_counts.permuted.ml.4.u.Rmd"))

saveRDS(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, paste0(save_path, "raw_results/ml_summary.A1.4.u_nonPWIDCoast_nonPWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDCoast_PWIDCoast, paste0(save_path, "raw_results/ml_summary.A1.4.u_nonPWIDCoast_PWIDCoast.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.A1.4.u_nonPWIDCoast_PWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, paste0(save_path, "raw_results/ml_summary.A1.4.u_nonPWIDNairobi_PWIDCoast.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.A1.4.u_nonPWIDNairobi_PWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_PWIDCoast_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.A1.4.u_PWIDCoast_PWIDNairobi.Rmd"))
```





#### Get a p-value that combines all the resamples (instead of averaging the p-values for each resample)

```{r A1.4 - p-value based on all resamples - u, eval = A1 & run4}


## average p -value ##

# within trait
within_p_nonPWIDCoast.u <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_nonPWIDCoast.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][8,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][6,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][6,]))  +
        mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][6,])) )
  withinVfrom_nonPWIDCoast.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][8,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][6,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][6,])  +
        unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][6,]) )
  
  within_p_nonPWIDCoast.u.averaged <- append(within_p_nonPWIDCoast.u, get_p_value(withinVfrom_nonPWIDCoast.observed, withinVfrom_nonPWIDCoast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_nonPWIDNairobi.u <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_nonPWIDNairobi.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][6,]))  +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][6,])) )
  withinVfrom_nonPWIDNairobi.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][6,])  +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][6,]) )
  
  within_p_nonPWIDNairobi.u.averaged <- append(within_p_nonPWIDCoast.u, get_p_value(withinVfrom_nonPWIDNairobi.observed, withinVfrom_nonPWIDNairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_PWIDCoast.u <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_PWIDCoast.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][5,]))  +
        mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi[[i]][6,])) )
  withinVfrom_PWIDCoast.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][5,])  +
        unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi[[i]][6,]) )
  
  within_p_PWIDCoast.u.averaged <- append(within_p_PWIDCoast.u, get_p_value(withinVfrom_PWIDCoast.observed, withinVfrom_PWIDCoast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_PWIDNairobi.u <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_PWIDNairobi.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][5,]))  +
        mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi[[i]][5,])) )
  withinVfrom_PWIDNairobi.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][5,])  +
        unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi[[i]][5,]) )
  
  within_p_PWIDNairobi.u.averaged <- append(within_p_PWIDCoast.u, get_p_value(withinVfrom_PWIDNairobi.observed, withinVfrom_PWIDNairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

withinTrait_PValues.4.u.average <- paste("Within non-PWID Coast (Average):", round(mean(within_p_nonPWIDCoast.u.averaged),3),
      "\nWithin non-PWID Nairobi (Average):", round(mean(within_p_nonPWIDNairobi.u.averaged),3),
      "\nWithin PWID Coast (Average):", round(mean(within_p_PWIDCoast.u.averaged),3),
      "\nWithin PWID Nairobi (Average):", round(mean(within_p_PWIDNairobi.u.averaged),3))
cat(withinTrait_PValues.4.u.average)





## combined p -values (combine subtrees then calculate 1 p-value) ##

# combine subtrees - observed
transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDNairobi_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_PWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)

# combine subtrees - permuted
transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb <- 
  matrix(do.call(cbind,transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi),nrow = 8, byrow= FALSE)


# Get p-values
withinVfrom_nonPWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [8,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,]))  +
      mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,])) )
withinVfrom_nonPWIDCoast.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [8,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,])  +
      unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,]) )
  
  within_p_nonPWIDCoast.u.comb  <- get_p_value(withinVfrom_nonPWIDCoast.observed.comb , withinVfrom_nonPWIDCoast.permuted.comb ,
                                         tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_nonPWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,]))  +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb[6,])) )
withinVfrom_nonPWIDNairobi.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,])  +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,]) )
  
  within_p_nonPWIDNairobi.u.comb  <- get_p_value(withinVfrom_nonPWIDNairobi.observed.comb , withinVfrom_nonPWIDNairobi.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,]))  +
      mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,])) )
withinVfrom_PWIDCoast.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,])  +
      unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,]) )
  
  within_p_PWIDCoast.u.comb  <- get_p_value(withinVfrom_PWIDCoast.observed.comb , withinVfrom_PWIDCoast.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,]))  +
      mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,])) )
withinVfrom_PWIDNairobi.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,])  +
      unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,]) )
  
  within_p_PWIDNairobi.u.comb  <- get_p_value(withinVfrom_PWIDNairobi.observed.comb , withinVfrom_PWIDNairobi.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinTrait_PValues.4.u.comb <- paste("Within non-PWID Coast (Combined):", round(mean(within_p_nonPWIDCoast.u.comb ),3),
      "\nWithin non-PWID Nairobi (Combined):", round(within_p_nonPWIDNairobi.u.comb, 3),
      "\nWithin PWID Coast (Combined):", round(within_p_PWIDCoast.u.comb, 3),
      "\nWithin PWID Nairobi (Combined):", round(within_p_PWIDNairobi.u.comb, 3))
cat(withinTrait_PValues.4.u.comb)







## Directional 

nonPWIDCoast_V_nonPWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,]))
nonPWIDCoast_V_nonPWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,])
  
nonPWIDCoast_V_nonPWIDNairobi.u.comb  <-get_p_value(nonPWIDCoast_V_nonPWIDNairobi.observed.comb,
                                                     nonPWIDCoast_V_nonPWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)



nonPWIDCoast_V_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,]))
nonPWIDCoast_V_PWIDCoast.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,])
  
nonPWIDCoast_V_PWIDCoast.u.comb  <-get_p_value(nonPWIDCoast_V_PWIDCoast.observed.comb,
                                                     nonPWIDCoast_V_PWIDCoast.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDCoast_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,]))
nonPWIDCoast_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,])
  
nonPWIDCoast_V_PWIDNairobi.u.comb  <-get_p_value(nonPWIDCoast_V_PWIDNairobi.observed.comb,
                                                     nonPWIDCoast_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDNairobi_V_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,]))
nonPWIDNairobi_V_PWIDCoast.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,])
  
nonPWIDNairobi_V_PWIDCoast.u.comb  <-get_p_value(nonPWIDNairobi_V_PWIDCoast.observed.comb,
                                                     nonPWIDNairobi_V_PWIDCoast.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDNairobi_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,]))
nonPWIDNairobi_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,])
  
nonPWIDNairobi_V_PWIDNairobi.u.comb  <-get_p_value(nonPWIDNairobi_V_PWIDNairobi.observed.comb,
                                                     nonPWIDNairobi_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


PWIDCoast_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,]))
PWIDCoast_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,])
  
PWIDCoast_V_PWIDNairobi.u.comb  <-get_p_value(PWIDCoast_V_PWIDNairobi.observed.comb,
                                                     PWIDCoast_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


directional_PValues.4.u.comb <- paste(
  "non-PWID Coast V non-PWID Nairobi (Combined):", round(nonPWIDCoast_V_nonPWIDNairobi.u.comb, 3),
  "\nnon-PWID Coast V PWID Coast (Combined):", round(nonPWIDCoast_V_PWIDCoast.u.comb, 3),
  "\nnon-PWID Coast V PWID Nairobi (Combined):", round(nonPWIDCoast_V_PWIDNairobi.u.comb, 3),
  "\nnon-PWID Nairobi V PWID Coast (Combined):", round(nonPWIDNairobi_V_PWIDCoast.u.comb, 3),
  "\nnon-PWID Nairobi V PWID Nairobi (Combined):", round(nonPWIDNairobi_V_PWIDNairobi.u.comb, 3),
  "\nPWID Coast V PWID Nairobi (Combined):", round(nonPWIDNairobi_V_PWIDNairobi.u.comb,3 )
       )
cat(directional_PValues.4.u.comb)


## Save all
PValues.4.u <- paste(withinTrait_PValues.4.u.average, "\n\n", withinTrait_PValues.4.u.comb, "\n\n",
                             directional_PValues.4.u.comb)

cat(PValues.4.u, file = paste0(save_path, "A1/A1_PWIDxregion_ASR_ml_uniform.4.p_value.txt"))
```



#### Illustration: different permutations
Not used in analysis: This is to show what the resampled trees (ie. random region assignments) look like
```{r A1.4 - permutation illustration - u, fig.width=10, fig.height=30, eval = A1 & run4}
# Uniform subsampling
png(paste0(save_path, "A1/A1_PWIDxregion_ASR_ml_uniform_subsamp_permutation_plots_4.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)

for(i in 1:4){
  pd.4.u.resampled_example <- resample_trait(pd.4.u[[1]])
  fit.4.u.resample_example <- pml(trees.Uniform_riskregion[[1]], pd.4.u.resampled_example)
  ap.4.u.resample_example <- ancestral.pml(fit.4.u.resample_example, "ml")
  
  plotAnc(trees.Uniform_riskregion[[1]], ap.4.u.resample_example, cex = 0.3, show.tip.label = FALSE,
          main = "Risk Population - Resamples (Resolved, Uniform Subsampling)")
}

dev.off()
#Also print to screen
knitr::include_graphics(paste0(save_path, "A1/A1_PWIDxregion_ASR_ml_uniform_subsamp_permutation_plots_4.png"))

par(mfrow=c(1,1))
```

TO DO: This should be showing the unresolved ancestor state probabilities (see .3.A1 for example). Why aren't those being correctly added to the tress?



### Illustration: Plot transitions counts against permutations
Not used in analysis
```{r A1.4 - plot transitions - u, fig.width = 10, eval = write_perms & A1 & run4}
# Uniform subsampling
transitions_plot.ml.4.u_PWIDCoast_PWIDNairobi <- suppressWarnings({plot_true_vs_permutations(
  transitions.df = transitions.ml.4.u_PWIDCoast_PWIDNairobi[[1]],
  transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[1]])})
transitions_plot.ml.4.u_PWIDCoast_PWIDNairobi

ggsave(paste0(save_path, "A1/A1_PWIDxregion_ASR_ml_subsamp_uniform_permtuations_PWIDCoast_PWIDNairobi_4.png"), transitions_plot.ml.4.u_PWIDCoast_PWIDNairobi, width = 15, height = 10, units = "in", dpi = 300)
```  



### Plot flow diagrams (from region & risk combined var)
Note: The plot mat function is finicky and I can't get it to print to the screen, therefore, the actual flow diagram is only saved
```{r A1.4 - flow diagrams - u, eval = A1 & run4}
# Uniform subsampling

#FROM is columns, TO is rows
riskregion.transitioncounts.u <- round(riskregion.transitioncounts.u,1)

riskregion.transitioncounts.u <- ifelse(is.na(riskregion.transitioncounts.u), 0 , riskregion.transitioncounts.u) #replace NA values with 0 - otherwise grey function won't work


# Set arrow widths as transition proportionate to pop size
transitions.colorgrad <- gray(1- (riskregion.transitioncounts.u/max(riskregion.transitioncounts.u, na.rm = TRUE))) %>% #This gives each value in the matrix as a percent of the max value (then inverses because lower values are darker) and then gets the corresponding greyscale level
  matrix(nrow = nrow(riskregion.transitioncounts.u), ncol = ncol(riskregion.transitioncounts.u), byrow = FALSE)

#Check - these should match up (the first is the matrix of transition counts, the second is that matrix represented as greyscale)
riskregion.transitioncounts.u
grid.raster(as.raster(transitions.colorgrad), width = 1, height = 1, interpolate = FALSE)


png(filename = paste0(save_path, "A1/A1_PWIDxregion_uniform_flow_diagram_4.png"))
  plotmat(riskregion.transitioncounts.u, pos = c(2, 2), 
          arr.width = 0.4, arr.type = "triangle", arr.col = transitions.colorgrad,
          arr.lcol = transitions.colorgrad, dtext = 0.25,
          self.cex = 0.5, self.shiftx = c(-0.05,0.05,-0.05,0.05),
          self.shifty = c(0.025,0.025,-0.025,-0.025), 
          box.lwd = 1, box.size = .05, box.type = "square",
          box.prop = .5, box.cex = .8, curve = 0.1, shadow.size = 0, relsize = 1.2,
          box.col = c("pink", "lightblue", "green", "yellow"))
dev.off()


```


### Drop objects
```{r drop A1.4 uniform vars, eval = A1 & run4}
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
     pd.4.u, fit.4.u, ap.4.u,

    #transition counts - true
      transitions.ml.4.u,
      transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi, transitions.ml.4.u_nonPWIDCoast_PWIDCoast,
      transitions.ml.4.u_nonPWIDCoast_PWIDNairobi, transitions.ml.4.u_nonPWIDNairobi_PWIDCoast,
      transitions.ml.4.u_PWIDCoast_PWIDNairobi,
    #transition counts - permuted
     transitions.permuted.ml.4.u,
      transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi, transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast,
      transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi, transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast,
      transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi,

    #Summaries
      ml_summary.4.u,
    
    
    #Examples for plotting - true
     fit.4.u.example, ap.4.u.example,
     #Examples for plotting - permuted
     pd.4.u.resampled_example, pd.4.u.resampled_example.phylo,
     fit.4.u.resample_example,
     ap.4.u.resample_example, ap.4.u.resample_examples.list,
     nodestates.4.u.resample_example,
     resolved.4.u.resample_example,
    
    #plots
    transitions_plot.ml.4.u,
  
    #P-values
    within_p_nonPWIDCoast.u, withinVfrom_nonPWIDCoast.observed, withinVfrom_nonPWIDCoast.permuted,
    within_p_nonPWIDNairobi.u, withinVfrom_nonPWIDNairobi.observed, withinVfrom_nonPWIDNairobi.permuted,
    within_p_PWIDCoast.u, withinVfrom_PWIDCoast.observed, withinVfrom_PWIDCoast.permuted,
    within_p_PWIDNairobi.u, withinVfrom_PWIDNairobi.observed, withinVfrom_PWIDNairobi.permuted,

    within_p_nonPWIDCoast.u.averaged, withinVfrom_nonPWIDCoast.observed.averaged, withinVfrom_nonPWIDCoast.permuted.averaged,
    within_p_nonPWIDNairobi.u.averaged, withinVfrom_nonPWIDNairobi.observed.averaged, withinVfrom_nonPWIDNairobi.permuted.averaged,
    within_p_PWIDCoast.u.averaged, withinVfrom_PWIDCoast.observed.averaged, withinVfrom_PWIDCoast.permuted.averaged,
    within_p_PWIDNairobi.u.averaged, withinVfrom_PWIDNairobi.observed.averaged, withinVfrom_PWIDNairobi.permuted.averaged,
        
    within_p_nonPWIDCoast.u.comb, withinVfrom_nonPWIDCoast.observed.comb, withinVfrom_nonPWIDCoast.permuted.comb,
    within_p_nonPWIDNairobi.u.comb, withinVfrom_nonPWIDNairobi.observed.comb, withinVfrom_nonPWIDNairobi.permuted.comb,
    within_p_PWIDCoast.u.comb, withinVfrom_PWIDCoast.observed.comb, withinVfrom_PWIDCoast.permuted.comb,
    within_p_PWIDNairobi.u.comb, withinVfrom_PWIDNairobi.observed.comb, withinVfrom_PWIDNairobi.permuted.comb    
    )})
}
```
NOT COMPLETE


## ML - risk & region combined - Proportionate subsampling (.4)

### Count transtions

```{r A1.4 - Count Transitions - p, fig.width=10, fig.height=30, eval = FALSE}
# Proportionate subsampling (.p)
pd.4.p <- lapply(trees.proportionate_regionrisk2, phylo_variable, metadata =  tree.hiv.meta, trait = "PWID_region.comb")

set.seed(1)
fit.4.p <- mapply(pml, trees.proportionate_regionrisk2, pd.4.p, SIMPLIFY = FALSE)
fit.4.p <- lapply(fit.4.p , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0))
fit.4.p <- lapply(fit.4.p , optim.pml, optEdge = TRUE, optRate=FALSE, 
                    control = pml.control(trace=0)) #Optimize edge lengths - not ideal but otherwise we get an error!
ap.4.p <- lapply(fit.4.p , ancestral.pml, type = "ml")
nodestates.ml.4.p <- lapply(ap.4.p, function(x) replicate(n_parsimony, resolve_ancestors(x, only_resolved = TRUE), simplify = FALSE))
ap.4.p[[1]] #CHECK site patterns (these should be alphabetical!)

transition_counts.ml.4.p <- mapply(function(x,y){
    lapply(x, function(z) { count_transitions2(z, tree = y)})
  }, nodestates.ml.4.p, lapply(trees.proportionate_regionrisk2, unroot.phylo), SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi <- lapply(transition_counts.ml.4.p, function(x){ #
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,2))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.p_nonPWIDCoast_PWIDCoast <- lapply(transition_counts.ml.4.p, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,3))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.p_nonPWIDCoast_PWIDNairobi <- lapply(transition_counts.ml.4.p, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

transitions.ml.4.p_nonPWIDNairobi_PWIDCoast <- lapply(transition_counts.ml.4.p, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,3))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.p_nonPWIDNairobi_PWIDNairobi <- lapply(transition_counts.ml.4.p, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

transitions.ml.4.p_PWIDCoast_PWIDNairobi <- lapply(transition_counts.ml.4.p, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

```


### Run Permutations

```{r A1.4 - permutations - p, eval = FALSE}
# Proportionate subsampling
set.seed(2)
transition_counts.permuted.ml.4.p <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      suppressWarnings({permute_tree(pd = x, #CAUTION: I have suppressed warnings!!!
                   tree = y, parsimony_method = "ml", optimize.edge = TRUE)}), simplify = FALSE),
  pd.4.p,
  trees.proportionate_regionrisk2, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.permuted.ml.4.p_nonPWIDCoast_nonPWIDNairobi <- lapply(transition_counts.permuted.ml.4.p, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,2))))})
transitions.permuted.ml.4.p_nonPWIDCoast_PWIDCoast <- lapply(transition_counts.permuted.ml.4.p, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,3))))})
transitions.permuted.ml.4.p_nonPWIDCoast_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.p, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,4))))})

transitions.permuted.ml.4.p_nonPWIDNairobi_PWIDCoast <- lapply(transition_counts.permuted.ml.4.p, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,3))))})
transitions.permuted.ml.4.p_nonPWIDNairobi_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.p, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,4))))})

transitions.permuted.ml.4.p_PWIDCoast_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.p, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(3,4))))})
```


### Summary Table

```{r A1.4 - Summary table - p, eval = FALSE, results='asis'}
# Proportionate subsampling:

##initialize and empty data frame to hold the transition counts between each group (for total tree)
riskregion.transitioncounts.p <- matrix(ncol = 4, nrow = 4)
colnames(riskregion.transitioncounts.p) <- c("nonPWIDCoast", "nonPWIDNairobi", "PWIDCoast", "PWIDNairobi")
rownames(riskregion.transitioncounts.p) <- c("nonPWIDCoast", "nonPWIDNairobi", "PWIDCoast", "PWIDNairobi")
#In the matrix, FROM is the column names and TO is the row names - verify this!

ml_summary.4.p_nonPWIDCoast_nonPWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk2,
       transitions.df = transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.p_nonPWIDCoast_nonPWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "nonPWID_Nairobi"), subtype = "A1 - nonPWIDCoast&nonPWIDNairobi",
                       binary_trait = FALSE)) %>%
  data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.p_nonPWIDCoast_nonPWIDNairobi <- apply(ml_summary.4.p_nonPWIDCoast_nonPWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.p_nonPWIDCoast_nonPWIDNairobi <- apply(ml_summary.4.p_nonPWIDCoast_nonPWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.p_nonPWIDCoast_nonPWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.p["nonPWIDNairobi", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_nonPWIDNairobi$trait0to1))
riskregion.transitioncounts.p["nonPWIDCoast", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_nonPWIDNairobi$trait1to0))
riskregion.transitioncounts.p["nonPWIDCoast", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_nonPWIDNairobi$within0)) #Also for within nonPWIDCoast
riskregion.transitioncounts.p["nonPWIDNairobi", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_nonPWIDNairobi$within1)) #Also for within nonPWIDNairobi


ml_summary.4.p_nonPWIDCoast_PWIDCoast <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk2,
       transitions.df = transitions.ml.4.p_nonPWIDCoast_PWIDCoast,
       transitions.permuted =  transitions.permuted.ml.4.p_nonPWIDCoast_PWIDCoast,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "PWID_Coast"), subtype = "A1 - nonPWIDCoast&PWIDCoast",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.p_nonPWIDCoast_PWIDCoast <- apply(ml_summary.4.p_nonPWIDCoast_PWIDCoast, 2, range) %>%
  as.data.frame()# range
ml_summary_comb.4.p_nonPWIDCoast_PWIDCoast <- apply(ml_summary.4.p_nonPWIDCoast_PWIDCoast, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.p_nonPWIDCoast_PWIDCoast) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.p["PWIDCoast", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_PWIDCoast$trait0to1))
riskregion.transitioncounts.p["nonPWIDCoast", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_PWIDCoast$trait1to0))
riskregion.transitioncounts.p["PWIDCoast", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_PWIDCoast$within1)) #Also for within PWIDCoast


ml_summary.4.p_nonPWIDCoast_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk2,
       transitions.df = transitions.ml.4.p_nonPWIDCoast_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.p_nonPWIDCoast_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "PWID_Nairobi"), subtype = "A1 - nonPWIDCoast&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.p_nonPWIDCoast_PWIDNairobi <- apply(ml_summary.4.p_nonPWIDCoast_PWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.p_nonPWIDCoast_PWIDNairobi <- apply(ml_summary.4.p_nonPWIDCoast_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.p_nonPWIDCoast_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.p["PWIDNairobi", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_PWIDNairobi$trait0to1))
riskregion.transitioncounts.p["nonPWIDCoast", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_PWIDNairobi$trait1to0))
riskregion.transitioncounts.p["PWIDNairobi", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDCoast_PWIDNairobi$within1)) #Also for within PWIDNairobi


ml_summary.4.p_nonPWIDNairobi_PWIDCoast <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk2,
       transitions.df = transitions.ml.4.p_nonPWIDNairobi_PWIDCoast,
       transitions.permuted =  transitions.permuted.ml.4.p_nonPWIDNairobi_PWIDCoast,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Nairobi", "PWID_Coast"), subtype = "A1 - nonPWIDNairobi&PWIDCoast",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.p_nonPWIDNairobi_PWIDCoast <- apply(ml_summary.4.p_nonPWIDNairobi_PWIDCoast, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.p_nonPWIDNairobi_PWIDCoast <- apply(ml_summary.4.p_nonPWIDNairobi_PWIDCoast, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.p_nonPWIDNairobi_PWIDCoast) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.p["PWIDCoast", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDNairobi_PWIDCoast$trait0to1))
riskregion.transitioncounts.p["nonPWIDNairobi", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDNairobi_PWIDCoast$trait1to0))

ml_summary.4.p_nonPWIDNairobi_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk2,
       transitions.df = transitions.ml.4.p_nonPWIDNairobi_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.p_nonPWIDNairobi_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("PWID_Nairobi", "PWID_Nairobi"), subtype = "A1 - nonPWIDNairobi&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.p_nonPWIDNairobi_PWIDNairobi <- apply(ml_summary.4.p_nonPWIDNairobi_PWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.p_nonPWIDNairobi_PWIDNairobi <- apply(ml_summary.4.p_nonPWIDNairobi_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.p_nonPWIDNairobi_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.p["PWIDNairobi", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDNairobi_PWIDNairobi$trait0to1))
riskregion.transitioncounts.p["nonPWIDNairobi", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.p_nonPWIDNairobi_PWIDNairobi$trait1to0))

ml_summary.4.p_PWIDCoast_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.proportionate_regionrisk2,
       transitions.df = transitions.ml.4.p_PWIDCoast_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.p_PWIDCoast_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("PWID_Coast", "PWID_Nairobi"), subtype = "A1 - PWIDCoast&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.p_PWIDCoast_PWIDNairobi <- apply(ml_summary.4.p_PWIDCoast_PWIDNairobi, 2, range) %>%
  as.data.frame() # range
ml_summary_comb.4.p_PWIDCoast_PWIDNairobi <- apply(ml_summary.4.p_PWIDCoast_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.p_PWIDCoast_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.p["PWIDNairobi", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.p_PWIDCoast_PWIDNairobi$trait0to1))
riskregion.transitioncounts.p["PWIDCoast", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.p_PWIDCoast_PWIDNairobi$trait1to0))


# Combine into 1 table
ml_summary.4.p <- rbind(ml_summary_comb.4.p_nonPWIDCoast_nonPWIDNairobi,
                              ml_summary_comb.4.p_nonPWIDCoast_PWIDCoast) %>%
  rbind(ml_summary_comb.4.p_nonPWIDCoast_PWIDNairobi) %>%
  rbind(ml_summary_comb.4.p_nonPWIDNairobi_PWIDCoast) %>%
  rbind(ml_summary_comb.4.p_nonPWIDNairobi_PWIDNairobi) %>%
  rbind(ml_summary_comb.4.p_PWIDCoast_PWIDNairobi)

#Print fancy table:
fancify_table(ml_summary.4.p, title = "SHARP ML - uniform subsampling", trait0 = "nonPWID_Coast, nonPWID_Coast, nonPWID_Coast, nonPWID_Nairobi, nonPWID_Nairobi, PWIDCoast", trait1 = "nonPWID_Nairobi, PWID_Coast, PWID_Nairobi, PWID_Coast, PWID_Nairobi, PWID_Nairobi") %T>% print(.) %>%
  save_kable(paste0(save_path, "A1/A1_PWIDxregion_ASR_ml_proportionate_nonPWIDCoast_PWIDCoast_summary_table_4.html"))
```

#### Get a p-value that combines all the resamples (instead of averaging the p-values for each resample)

```{r A1.4 - p-value based on all resamples - p, eval = FALSE}
# Proportionate subsampling

within_p_nonPWIDCoast.p <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_nonPWIDCoast.observed <-
    mean(unlist(transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi[[i]][8,])) / 
    ( mean(unlist(transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi[[i]][6,])) +
        mean(unlist(transitions.ml.4.p_nonPWIDCoast_PWIDCoast[[i]][6,]))  +
        mean(unlist(transitions.ml.4.p_nonPWIDCoast_PWIDNairobi[[i]][6,])) )
  withinVfrom_nonPWIDCoast.permuted <- unlist(transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi[[i]][8,]) / 
    ( unlist(transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi[[i]][6,]) +
        unlist(transitions.ml.4.p_nonPWIDCoast_PWIDCoast[[i]][6,])  +
        unlist(transitions.ml.4.p_nonPWIDCoast_PWIDNairobi[[i]][6,]) )
  
  within_p_nonPWIDCoast.p <- append(within_p_nonPWIDCoast.p, get_p_value(withinVfrom_nonPWIDCoast.observed, withinVfrom_nonPWIDCoast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_nonPWIDNairobi.p <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_nonPWIDNairobi.observed <-
    mean(unlist(transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi[[i]][5,])) +
        mean(unlist(transitions.ml.4.p_nonPWIDNairobi_PWIDCoast[[i]][6,]))  +
        mean(unlist(transitions.ml.4.p_nonPWIDNairobi_PWIDNairobi[[i]][6,])) )
  withinVfrom_nonPWIDNairobi.permuted <- unlist(transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi[[i]][7,]) / 
    ( unlist(transitions.ml.4.p_nonPWIDCoast_nonPWIDNairobi[[i]][5,]) +
        unlist(transitions.ml.4.p_nonPWIDNairobi_PWIDCoast[[i]][6,])  +
        unlist(transitions.ml.4.p_nonPWIDNairobi_PWIDNairobi[[i]][6,]) )
  
  within_p_nonPWIDNairobi.p <- append(within_p_nonPWIDNairobi.p, get_p_value(withinVfrom_nonPWIDNairobi.observed, withinVfrom_nonPWIDNairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_PWIDCoast.p <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_PWIDCoast.observed <-
    mean(unlist(transitions.ml.4.p_nonPWIDCoast_PWIDCoast[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.p_nonPWIDCoast_PWIDCoast[[i]][5,])) +
        mean(unlist(transitions.ml.4.p_nonPWIDNairobi_PWIDCoast[[i]][5,]))  +
        mean(unlist(transitions.ml.4.p_PWIDCoast_PWIDNairobi[[i]][6,])) )
  withinVfrom_PWIDCoast.permuted <- unlist(transitions.ml.4.p_nonPWIDCoast_PWIDCoast[[i]][7,]) / 
    ( unlist(transitions.ml.4.p_nonPWIDCoast_PWIDCoast[[i]][5,]) +
        unlist(transitions.ml.4.p_nonPWIDNairobi_PWIDCoast[[i]][5,])  +
        unlist(transitions.ml.4.p_PWIDCoast_PWIDNairobi[[i]][6,]) )
  
  within_p_PWIDCoast.p <- append(within_p_PWIDCoast.p, get_p_value(withinVfrom_PWIDCoast.observed, withinVfrom_PWIDCoast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}


within_p_PWIDNairobi.p <- c()
for(i in 1:n_subsamples_A1){
  withinVfrom_PWIDNairobi.observed <-
    mean(unlist(transitions.ml.4.p_nonPWIDCoast_PWIDNairobi[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.p_nonPWIDCoast_PWIDNairobi[[i]][5,])) +
        mean(unlist(transitions.ml.4.p_nonPWIDNairobi_PWIDNairobi[[i]][5,]))  +
        mean(unlist(transitions.ml.4.p_PWIDCoast_PWIDNairobi[[i]][5,])) )
  withinVfrom_PWIDNairobi.permuted <- unlist(transitions.ml.4.p_nonPWIDCoast_PWIDNairobi[[i]][7,]) / 
    ( unlist(transitions.ml.4.p_nonPWIDCoast_PWIDNairobi[[i]][5,]) +
        unlist(transitions.ml.4.p_nonPWIDNairobi_PWIDNairobi[[i]][5,])  +
        unlist(transitions.ml.4.p_PWIDCoast_PWIDNairobi[[i]][5,]) )
  
  within_p_PWIDNairobi.p <- append(within_p_PWIDCoast.p, get_p_value(withinVfrom_PWIDNairobi.observed, withinVfrom_PWIDNairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}


withinTrait_PValue.4.p <- paste("Within non-PWID Coast:", round(mean(within_p_nonPWIDCoast.p),3),
                      "\nWithin non-PWID Nairobi:", round(mean(within_p_nonPWIDNairobi.p),3),
                      "\nWithin PWID Coast:", round(mean(within_p_PWIDCoast.p),3),
                      "\nWithin PWID Nairobi:", round(mean(within_p_PWIDNairobi.p),3))
withinTrait_PValue.4.p
cat(withinTrait_PValue.4.p, file = paste0(save_path, "A1/A1_PWIDxregion_ASR_ml_proportionate.4.p_value.txt"))
```


### Plot flow diagrams (from region & risk combined var)
This is the same as the uniform subsampling flow diagram, except it incorporates arrow width.
  * Arrow width is the estimated amount of transitions between each group
  * Arrow color  is the estimated amount of transitions between each group proportionate to population size  
This isn't working will. I'm not goign to use.  
```{r A1.4 - flow diagrams - p, eval = FALSE}
# Proportionate subsampling

riskregion.transitioncounts.p <- round(riskregion.transitioncounts.p, 1)

riskregion.transitioncounts.p <- ifelse(is.na(riskregion.transitioncounts.p), 0 , riskregion.transitioncounts.p) #replace NA values with 0 - otherwise grey function won't work


# Set arrow transparency as transition proportionate to pop size
prop_transitions <- sweep(riskregion.transitioncounts.p, 2, region_risk_comb_pop_sizes, "/")
# Scale the matrix proportionally
prop_transitions.scaled <- 1 - ((prop_transitions - min(prop_transitions)) / (max(prop_transitions) - min(prop_transitions)) * (1 - 0.05) + 0.05) #0.15 and 1 are the values I want the colors to fall between (otherwise some arrows will be completely white!)
diag(prop_transitions.scaled) <- 1

prop_transitions.colorgrad <- gray(prop_transitions.scaled) %>% #This gives each value in the matrix as a percent of the max value (then inverses because lower values are darker) and then gets the corresponding greyscale level - it's also scaled so the lowest value is light grey and not white, that way all the arrows show up
  matrix(nrow = nrow(riskregion.transitioncounts.p), ncol = ncol(riskregion.transitioncounts.p), byrow = FALSE)

#Check - these should match up 
prop_transitions
grid.raster(as.raster(prop_transitions.colorgrad), width = 1, height = 1, interpolate = FALSE)


png(filename = paste0(save_path, "A1/A1_PWIDxregion_proportionate_flow_diagram_4.png"))
  plotmat(riskregion.transitioncounts.p, pos = c(2, 2), lwd = .15*riskregion.transitioncounts.p,
          arr.width = 0.4, arr.type = "triangle", arr.col = prop_transitions.colorgrad,
          arr.lcol = prop_transitions.colorgrad, box.lwd = 1, dtext = 0.25,
          self.cex = 0.5, self.shiftx = c(-0.05,0.05,-0.05,0.05),
          self.shifty = c(0.025,0.025,-0.025,-0.025),
          box.size = .05*sqrt(region_risk_comb_pop_sizes), box.type = "square",
          box.prop = .5, box.cex = .7, curve = 0.1, shadow.size = 0, relsize = 1.2,
          box.col = c("pink", "lightblue", "green", "yellow"))
dev.off()

```



### Drop objects
```{r drop A1.4 proportionate vars, eval = FALSE}
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
     pd.4.p, fit.4.p, ap.4.p,

    #transition counts - true
     transitions.ml.4.p,
    #transition counts - permuted
     transitions.permuted.ml.4.p,
     ml_summary.4.p,
     
    #Examples for plotting - true
     fit.4.p.example, ap.4.p.example,
     #Examples for plotting - permuted
     pd.4.p.resampled_example, pd.4.p.resampled_example.phylo,
     fit.4.p.resample_example,
     ap.4.p.resample_example, ap.4.p.resample_examples.list,
     nodestates.4.p.resample_example,
     resolved.4.p.resample_example,
    
    #plots
    transitions_plot.ml.4.p)})
}
```


<br><br><br>




## ML - PWID cluster tree - risk (.5) - NOT USING

### Count Transitions
```{r A1.5 - Count Transitions, fig.width=10, fig.height=30, eval = A1 & run5}

###

# Full tree
pd.5 <- phylo_variable(tree.hiv.meta, tree.PWID_clust, "risk4.F")

set.seed(1) #set seed before any process involving randomness (usually replicate() functions, so results are reproducible)
fit.5 <- pml(tree.PWID_clust, pd.5)
fit.5 <- optim.pml(fit.5, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.5 <- ancestral.pml(fit.5, "ml")

plotAnc(tree.PWID_clust, ap.5, cex = 0.25, show.tip.label = FALSE,
        main = "PWDI&Region combined - A1 (tree restricted to clusters containing PWID seqs)")

nodestates.ml.5.u <-
  replicate(n_parsimony,
            resolve_ancestors(ap.5, only_resolved = TRUE), simplify = FALSE) 
transition_counts.ml.5.u <- lapply(nodestates.ml.5.u, count_transitions2, tree = tree.PWID_clust)

#Get counts for different pairs of key pops
transitions.ml.5_FSW_HET <- t(do.call(rbind, lapply(transition_counts.ml.5.u, summarize_transitions, categories_0_1 = c(1,2))))
transitions.ml.5_FSW_MSM <- t(do.call(rbind, lapply(transition_counts.ml.5.u, summarize_transitions, categories_0_1 = c(1,3))))
transitions.ml.5_FSW_PWID <- t(do.call(rbind, lapply(transition_counts.ml.5.u, summarize_transitions, categories_0_1 = c(1,4))))
transitions.ml.5_HET_MSM <- t(do.call(rbind, lapply(transition_counts.ml.5.u, summarize_transitions, categories_0_1 = c(2,3))))
transitions.ml.5_HET_PWID <- t(do.call(rbind, lapply(transition_counts.ml.5.u, summarize_transitions, categories_0_1 = c(2,4))))
transitions.ml.5_MSM_PWID <- t(do.call(rbind, lapply(transition_counts.ml.5.u, summarize_transitions, categories_0_1 = c(3,4))))


```

### Run permutations 
```{r A1.5 - permutations, eval = A1 & run5}
set.seed(2)
transition_counts.permuted.ml.5 <-
  replicate(
    n_permutations,
    permute_tree(pd.5, tree.PWID_clust, "ml"),
    simplify = FALSE
  )

levels(tree.hiv.meta$risk4.F) #Confirm levels are in alphabetical order

#Get counts for different pairs of key pops
transitions.permuted.ml.5_FSW_HET <- t(do.call(rbind, lapply(transition_counts.permuted.ml.5, mean_transitionsXparsimony, categories_0_1 = c(1,4))))
transitions.permuted.ml.5_FSW_MSM <- t(do.call(rbind, lapply(transition_counts.permuted.ml.5, mean_transitionsXparsimony, categories_0_1 = c(1,2))))
transitions.permuted.ml.5_FSW_PWID <- t(do.call(rbind, lapply(transition_counts.permuted.ml.5, mean_transitionsXparsimony, categories_0_1 = c(1,3))))
transitions.permuted.ml.5_HET_MSM <- t(do.call(rbind, lapply(transition_counts.permuted.ml.5, mean_transitionsXparsimony, categories_0_1 = c(1,4))))
transitions.permuted.ml.5_HET_PWID <- t(do.call(rbind, lapply(transition_counts.permuted.ml.5, mean_transitionsXparsimony, categories_0_1 = c(2,3))))
transitions.permuted.ml.5_MSM_PWID <- t(do.call(rbind, lapply(transition_counts.permuted.ml.5, mean_transitionsXparsimony, categories_0_1 = c(3,4))))

```


### Summary Table 

```{r A1.5 - Summary table, eval = A1 & run5, results='asis'}
# Full tree
ml_summary.5_FSW_HET <- transitions_summary_table(meta.tree = tree.hiv.meta,
                          tree = tree.PWID_clust,
                          transitions.df = transitions.ml.5_FSW_HET,
                          transitions.permuted =  transitions.permuted.ml.5_FSW_HET,
                          trait = "risk4.F", subtype = "A1 - FSW&HET", trait_cats = c("FSW", "HET"),
                          binary_trait = FALSE)

ml_summary.5_FSW_MSM <- transitions_summary_table(meta.tree = tree.hiv.meta,
                          tree = tree.PWID_clust,
                          transitions.df = transitions.ml.5_FSW_MSM,
                          transitions.permuted =  transitions.permuted.ml.5_FSW_MSM,
                          trait = "risk4.F", subtype = "A1 - FSW&MSM", trait_cats = c("FSW", "MSM"),
                          binary_trait = FALSE)

ml_summary.5_FSW_PWID <- transitions_summary_table(meta.tree = tree.hiv.meta,
                          tree = tree.PWID_clust,
                          transitions.df = transitions.ml.5_FSW_PWID,
                          transitions.permuted =  transitions.permuted.ml.5_FSW_PWID,
                          trait = "risk4.F", subtype = "A1 - FSW&PWID", trait_cats = c("FSW", "PWID"),
                          binary_trait = FALSE)

ml_summary.5_HET_MSM <- transitions_summary_table(meta.tree = tree.hiv.meta,
                          tree = tree.PWID_clust,
                          transitions.df = transitions.ml.5_HET_MSM,
                          transitions.permuted =  transitions.permuted.ml.5_HET_MSM,
                          trait = "risk4.F", subtype = "A1 - HET&MSM", trait_cats = c("HET", "MSM"),
                          binary_trait = FALSE)

ml_summary.5_HET_PWID <- transitions_summary_table(meta.tree = tree.hiv.meta,
                          tree = tree.PWID_clust,
                          transitions.df = transitions.ml.5_HET_PWID,
                          transitions.permuted =  transitions.permuted.ml.5_HET_PWID,
                          trait = "risk4.F", subtype = "A1 - HET&PWID", trait_cats = c("HET", "PWID"),
                          binary_trait = FALSE)

ml_summary.5_MSM_PWID <- transitions_summary_table(meta.tree = tree.hiv.meta,
                          tree = tree.PWID_clust,
                          transitions.df = transitions.ml.5_MSM_PWID,
                          transitions.permuted =  transitions.permuted.ml.5_MSM_PWID,
                          trait = "risk4.F", subtype = "A1 - MSM&PWID", trait_cats = c("MSM", "PWID"),
                          binary_trait = FALSE)


ml_summary.5 <- rbind(ml_summary.5_FSW_HET, ml_summary.5_FSW_MSM) %>%
  rbind(ml_summary.5_FSW_PWID) %>% rbind(ml_summary.5_HET_MSM)  %>%
  rbind(ml_summary.5_HET_PWID) %>% rbind(ml_summary.5_MSM_PWID)
fancify_table(ml_summary.5, title = "SHARP ML - all sequences",
              trait0 = "FSW, FSW, FSW, HET, HET, MSM",
              trait1 = "HET, MSM, PWID, MSM, PWID, PWID") %T>% print(.) %>%
  save_kable(paste0(save_path, "A1/A1_PWIDclust_ASR_ml_summary_table_5.html"))
```


#### Illustration: different permutations
Not used in analysis: This is to show what the resampled trees (ie. random region assignments) look like
```{r A1.5 - plot permutations, fig.width=10, fig.height=30, eval = A1 & run5}
png(paste0(save_path, "A1/PWID_clust_ASR_ml_subsamp_uniform_permutation_plots_5.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)

for(i in 1:4){
  pd.5.resampled_example <- resample_trait(pd.5)
  fit.5.resample_example <- pml(tree.PWID_clust, pd.5.resampled_example)
  ap.5.resample_example <- ancestral.pml(fit.5.resample_example, "ml")
  
  plotAnc(tree.PWID_clust, ap.5.resample_example, cex = 0.4, show.tip.label = FALSE,
          main = "Risk Population (tree restricted to clusters containing PWID -\n
          Resampled Leaves (Uniform Subsampling)")
}

dev.off()
knitr::include_graphics(paste0(save_path, "A1/PWID_clust_ASR_ml_subsamp_uniform_permutation_plots_5.png"))

par(mfrow=c(1,1))
```
Notice that the nodestates tend to converge on one region as we go toward the root.  
I believe this explains why the permuted import and export counts follow a bi-modal distribution.  




### Illustration: Plot transitions counts against permutations  
Not used in analysis
```{r A1.5 - plot transitions, fig.width = 10, eval = write_perms & A1 & run5}

transitions_plot.ml.5 <- suppressWarnings({plot_true_vs_permutations(
  transitions.df = transitions.ml.5_HET_PWID,
  transitions.permuted =  transitions.permuted.ml.5_HET_PWID)})
transitions_plot.ml.5

ggsave(paste0(save_path, "A1/A1_PWID_clust_ASR_transitions_permuted_HET_PWID_5.png"), transitions_plot.ml.5, width = 15, height = 10, units = "in", dpi = 300)

```  



### Drop objects
```{r drop A1.5 vars, eval = A1 & run5}
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
    pd.5, fit.5, ap.5,
     pd.5.u, fit.5.u, ap.5.u,
     pd.5.p, fit.5.p, ap.5.p,
     
    #transition counts - true
     transitions.ml.5, transitions.ml.5.u, transitions.ml.5.p,
    #transition counts - permuted
     transitions.permuted.ml.5, transitions.permuted.ml.5.u, transitions.permuted.ml.5.p,
     ml_summary.5, ml_summary.5.u, ml_summary.5.p,
     
    #Examples for plotting - true
     fit.5.example, ap.5.example, fit.5.u.example,
     ap.5.u.example, fit.5.p.example, ap.5.p.example,
     #Examples for plotting - permuted
     pd.5.resampled_example, pd.5.resampled_example.phylo,
     pd.5.u.resampled_example, pd.5.u.resampled_example.phylo,
     pd.5.p.resampled_example, pd.5.p.resampled_example.phylo,
     fit.5.resample_example, fit.5.u.resample_example, fit.5.p.resample_example,
     ap.5.resample_example, ap.5.resample_examples.list,
     ap.5.u.resample_example, ap.5.u.resample_examples.list,
     ap.5.p.resample_example, ap.5.p.resample_examples.list,
     nodestates.5.resample_example, nodestates.5.u.resample_example, nodestates.5.p.resample_example,
     resolved.5.resample_example, resolved.5.u.resample_example, resolved.5.p.resample_example,
    
    #plots
    transitions_plot.ml.5, transitions_plot.ml.5.u, transitions_plot.ml.5.p)})
}
```



# Drop all files (but keep functions and constants)
```{r drop A1 objects, eval = drop_ASR & A1}
rm(list = setdiff(setdiff(ls(), lsf.str()),
                  #Keep these:
                  c("save_path", "drop_ASR", "write_perms", "C", "D",
                    "SHARP_seq_names", 
                    "n_parsimony", "n_permutations", "n_subsamples_C", "n_subsamples_D")))
```















# SUBTYPE C



## Read in data

### tree data
```{r C - read in tree data, eval = C}
# SHARP and published
tree.hiv <- readRDS("../HIV/tree.hiv.CN.C.rds") #tree data object
tree.hiv.meta <- readRDS("../HIV/meta_tree.hiv.CN.C.rds") %>%
  select(-c(parent, node, branch.length)) #metadata

```  

### sequence lists
```{r C - read in seq lists, eval = C}
# Single
Uniform_region.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_region.C.seqs.rds")
Uniform_risk.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_risk.C.seqs.rds")
Uniform_regionrisk.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_regionrisk.C.seqs.rds")

# Lists
Uniform_region.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_region.C.seqs.list.rds")
Uniform_risk.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_risk.C.seqs.list.rds")
Uniform_regionrisk.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_regionrisk.C.seqs.list.rds")

```

TO DO: Add Uniform_region_SHARP.seqs.list (this will be quire small)


### check that trees are binary (bifurcating) and rooted  
```{r C - check binary and bifurcating, eval = C}
is.binary.phylo(tree.hiv)
is.rooted.phylo(tree.hiv) #It's actually ok that this is FALSE
```


## Extract trees


### Downsample trees - Uniform subsampling

#### Downsample
```{r C - downsampling trees - SHARP}
# downsample trees based on pre-specified filters
### First specify leaves NOT in the filter (thus the X_)
X_Uniform_region.seqs.list <-
  lapply(Uniform_region.seqs.list[1:n_subsamples_C],  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
X_Uniform_risk.seqs.list <-
  lapply(Uniform_risk.seqs.list[1:n_subsamples_C],  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
X_Uniform_riskregion.seqs.list <-
  lapply(Uniform_regionrisk.seqs.list[1:n_subsamples_C],  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})



# Drop leaves not in the filter
trees.Uniform_region <- lapply(X_Uniform_region.seqs.list, function(x){ape::drop.tip(tree.hiv, x)})
trees.Uniform_risk <- lapply(X_Uniform_risk.seqs.list, function(x){ape::drop.tip(tree.hiv, x)})
trees.Uniform_riskregion <- lapply(X_Uniform_riskregion.seqs.list, function(x){ape::drop.tip(tree.hiv, x)})


# Count number of branches (goes into ARS tables)
nrow(trees.Uniform_risk[[1]]$edge)
nrow(trees.Uniform_riskregion[[1]]$edge)
```





## ANCESTRAL STATE RESCONSTRUCTION




## ML - region - SHARP PWID only - region (.1) - NOT DONE YET

### Count Transitions  
```{r C.1 - Count Transitions, fig.width=10, fig.height=5, eval = FALSE}

###

# Uniform subsampling (.u)
pd.1.u <- lapply(trees.Uniform_region_SHARP, phylo_variable, metadata = tree.SHARP_hiv.meta, trait = "region.CN")

set.seed(1)
fit.1.u <- mapply(pml, trees.Uniform_region_SHARP, pd.1.u, SIMPLIFY = FALSE)
fit.1.u <- lapply(fit.1.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.1.u <- lapply(fit.1.u , ancestral.pml, type = "ml")
transitions.ml.1.u <-
  mapply(
    function(x, y)
      replicate(n_parsimony, resolve_and_summarize_transitions(x, y)),
    ap.1.u,
    trees.Uniform_region_SHARP,
    SIMPLIFY = FALSE
  )

plotAnc(trees.Uniform_region_SHARP[[1]], ap.1.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "SHARP - Region - A1 (Uniform subsampling")


# proportionate subsampling (.p)
pd.1.p <- lapply(trees.proportionate_region_SHARP, phylo_variable, metadata =  tree.SHARP_hiv.meta, trait = "region.CN")

set.seed(1)
fit.1.p <- mapply(pml, trees.proportionate_region_SHARP, pd.1.p, SIMPLIFY = FALSE)
fit.1.p <- lapply(fit.1.p, optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.1.p <- lapply(fit.1.p, ancestral.pml, type = "ml")
transitions.ml.1.p <-
  mapply(
    function(x, y)
      replicate(n_parsimony, resolve_and_summarize_transitions(x, y)),
    ap.1.p,
    trees.proportionate_region_SHARP,
    SIMPLIFY = FALSE
  )

plotAnc(trees.proportionate_region_SHARP[[1]], ap.1.p[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "SHARP - Region - A1 (Proportionate subsampling)")
```

### Run permutations 
```{r C.1 - permutations, eval = FALSE}
# Uniform subsampling
set.seed(2)
transition_counts.permuted.ml.1.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.1.u,
  trees.Uniform_region_SHARP, SIMPLIFY = FALSE
)
transitions.permuted.ml.1.u <- lapply(transition_counts.permuted.ml.1.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony)))})

# Proportionate subsampling
set.seed(2)
transition_counts.permuted.ml.1.p <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.1.p,
  trees.proportionate_region_SHARP, SIMPLIFY = FALSE
)
transitions.permuted.ml.1.p <- lapply(transition_counts.permuted.ml.1.p, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony)))})
```


### Summary Table

```{r C.1 - Summary table, eval = FALSE, results='asis'}

# Uniform subsampling (.u):
ml_summary.1.u <- mapply(transitions_summary_table,
       meta.tree = rep(list(tree.SHARP_hiv.meta), n_subsamples_A1),
       tree = trees.Uniform_region_SHARP,
       transitions.df = transitions.ml.1.u,
       transitions.permuted =  transitions.permuted.ml.1.u,
       trait = "region.CN", subtype = "C (Uniform)") %>%
  as.data.frame() %>% t()
ml_summary_range.1.u <- apply(ml_summary.1.u, 2, range) %>% as.data.frame() #ranges across subsamples
ml_summary_mean.1.u <- apply(ml_summary.1.u, 2, get_subtree_means) %>% t() #mean across subsamples
ml_summary.comb.1.u <- rbind(ml_summary_mean.1.u, ml_summary_range.1.u) #combine mean and ranges
fancify_table(ml_summary.comb.1.u , title = "SHARP ML - uniform subsampling - range and mean",
              trait0 = "Coast", trait1 = "Nairobi") %T>% print(.) %>%
  save_kable(paste0(save_path, "C/C_SHARP_region_among_PWID_ASR_ml_unifrom_subsamp_SHARP_summary_table_1.html"))


# Proportionate subsampling (.p):
ml_summary.1.p <- mapply(transitions_summary_table,
       meta.tree = rep(list(tree.SHARP_hiv.meta), n_subsamples_A1.prop),
       tree = trees.proportionate_region_SHARP,
       transitions.df = transitions.ml.1.p,
       transitions.permuted =  transitions.permuted.ml.1.p,
       trait = "region.CN", subtype = "C (proportionate)") %>%
  as.data.frame() %>% t()
ml_summary_range.1.p <- apply(ml_summary.1.p, 2, range) %>% as.data.frame()
ml_summary_mean.1.p <- apply(ml_summary.1.p, 2, get_subtree_means) %>% t() #mean across subsamples
ml_summary.comb.1.p <- rbind(ml_summary_range.1.p, ml_summary_mean.1.p)
#Print both ranges:
fancify_table(ml_summary.comb.1.p, title = "SHARP ML - proportionate subsampling",
              trait0 = "Coast", trait1 = "Nairobi") %T>% print(.)  %>%
  save_kable(paste0(save_path, "C/C_SHARP_region_among_PWID_ASR_ml_proportionate_subsamp_SHARP_summary_table_1.html"))
```



TO DO: Get the SHARP_only_region tree for C so I can run the above, add these objects to the drop chunk, repeat for subtype D






## ML - risk (.3)

### Count Transitions

```{r C.3 - Count Transitions - u, fig.width=10, fig.height=10, eval = C & run3}
# Uniform subsampling (.u)
pd.3.u <- lapply(trees.Uniform_risk, phylo_variable, metadata =  tree.hiv.meta, trait = "risk4.F")

set.seed(1)
fit.3.u <- mapply(pml, trees.Uniform_risk, pd.3.u, SIMPLIFY = FALSE)
fit.3.u <- lapply(fit.3.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.3.u <- lapply(fit.3.u , ancestral.pml, type = "ml")
nodestates.ml.3.u <- lapply(ap.3.u, function(x) replicate(n_parsimony, resolve_ancestors(x, only_resolved = TRUE), simplify = FALSE))
ap.3.u #CHECK site patterns (these should be alphabetical!)

transition_counts.ml.3.u <- mapply(function(x,y){
    lapply(x, function(z) { count_transitions2(z, tree = y)})
  }, nodestates.ml.3.u, trees.Uniform_risk, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.ml.3.u_FSW_PWID <- lapply(transition_counts.ml.3.u, function(x){ #
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,4))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.3.u_HET_PWID <- lapply(transition_counts.ml.3.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,4))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.3.u_MSM_PWID <- lapply(transition_counts.ml.3.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

#Visualize tree
plotAnc(trees.Uniform_risk[[1]], ap.3.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "Risk Population - C (Uniform Subsampling)")
```

### Run permutations
```{r C.3 - permutations - u, eval = C & run3}
# Uniform subsampling
set.seed(2)
transition_counts.permuted.ml.3.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.3.u,
  trees.Uniform_risk, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.permuted.ml.3.u_FSW_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,4))))})
transitions.permuted.ml.3.u_HET_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,4))))})
transitions.permuted.ml.3.u_MSM_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(3,4))))})
```


### Summary Table 

```{r C.3 - Summary table - u, eval = C & run3, results='asis'}
# Uniform subsampling:
ml_summary.3.u_FSW_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_FSW_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_FSW_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F",
                       trait_cats = c("FSW", "PWID"), subtype = "C - FSW&PWID",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_FSW_PWID <- apply(ml_summary.3.u_FSW_PWID, 2, range) %>% as.data.frame
ml_summary.3.u_FSW_PWID <- apply(ml_summary.3.u_FSW_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_FSW_PWID) #add mean

ml_summary.3.u_HET_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_HET_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_HET_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("HET", "PWID"),
                       subtype = "C - HET&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_HET_PWID <- apply(ml_summary.3.u_HET_PWID, 2, range) %>% as.data.frame #range
ml_summary.3.u_HET_PWID <- apply(ml_summary.3.u_HET_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_HET_PWID) #add mean

ml_summary.3.u_MSM_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_MSM_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_MSM_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("MSM", "PWID"),
                       subtype = "C - MSM&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_MSM_PWID <- apply(ml_summary.3.u_MSM_PWID, 2, range) %>% as.data.frame #range
ml_summary.3.u_MSM_PWID <- apply(ml_summary.3.u_MSM_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_MSM_PWID) #add mean



# Combine into 1 table
ml_summary.3.u <- rbind(ml_summary.3.u_FSW_PWID, ml_summary.3.u_HET_PWID) %>%
  rbind(ml_summary.3.u_MSM_PWID)

#Print fancy table:
fancify_table(ml_summary.3.u, title = "SHARP ML - uniform subsampling", trait0 = "FSW, HET, MSM", trait1 = "PWID, PWID, PWID") %T>% print(.) %>%
  save_kable(paste0(save_path, "C/C_risk_ASR_ml_uniform_summary_table_3.html"))
```



### Save Raw Result Data
```{r C.3 - save backup data - u, eval = C & run3 & save_backup}
saveRDS(transition_counts.ml.3.u, paste0(save_path, "raw_results/transition_counts.ml.C.3.u.Rmd"))
saveRDS(transition_counts.permuted.ml.3.u, paste0(save_path, "raw_results/transition_counts.permuted.ml.C.3.u.Rmd"))

saveRDS(ml_summary.3.u_FSW_PWID, paste0(save_path, "raw_results/ml_summary.C.3.u_FSW_PWID.Rmd"))
saveRDS(ml_summary.3.u_MSM_PWID, paste0(save_path, "raw_results/ml_summary.C.3.u_MSM_PWID.Rmd"))
saveRDS(ml_summary.3.u_HET_PWID, paste0(save_path, "raw_results/ml_summary.C.3.u_HET_PWID.Rmd"))

```



#### Get within-group P value
Within group p-value is a ratio of transitions within the group vs all transitions from the group. Since summary table only uses the binary comparisons, we calculate this p-value separately

```{r C.3 - p-value based on all resamples - u, eval = C & run3}
# Within trait
### PWID (average over subtrees)
within_p_PWID.u.3 <- c()
for(i in 1:n_subsamples_C){
  withinVfrom_PWID.observed <- mean(unlist(transitions.ml.3.u_MSM_PWID[[i]][7,])) / 
    ( mean(unlist(transitions.ml.3.u_MSM_PWID[[i]][5,])) +
        mean(unlist(transitions.ml.3.u_FSW_PWID[[i]][5,]))  +
        mean(unlist(transitions.ml.3.u_HET_PWID[[i]][5,])) )
  withinVfrom_PWID.permuted <- unlist(transitions.permuted.ml.3.u_MSM_PWID[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID[[i]][5,]) +
        unlist(transitions.permuted.ml.3.u_FSW_PWID[[i]][5,])  +
        unlist(transitions.permuted.ml.3.u_HET_PWID[[i]][5,]) )
  
  within_p_PWID.u.3 <- append(within_p_PWID.u.3, get_p_value(withinVfrom_PWID.observed, withinVfrom_PWID.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

withinPWID_PValue.averaged <- paste("Within vs from PWID (averaged): ", round(mean(within_p_PWID.u.3), 3))
withinPWID_PValue.averaged 


### PWID (combine subtrees & calc 1 p-value)

#Combine across subtrees
transitions.ml.3.u_MSM_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_MSM_PWID), nrow = 8, byrow= FALSE)
#do.call(cbind, lapply(transitions.ml.3.u_FSW_PWID, as.data.frame))
transitions.ml.3.u_FSW_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_FSW_PWID), nrow = 8, byrow= FALSE)
transitions.ml.3.u_HET_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_HET_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_MSM_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_MSM_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_FSW_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_FSW_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_HET_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_HET_PWID), nrow = 8, byrow= FALSE)

#Get P-value
  withinVfrom_PWID.observed.comb <- mean(unlist(transitions.ml.3.u_MSM_PWID.comb[7,])) / 
    ( mean(unlist(transitions.ml.3.u_MSM_PWID.comb[5,])) +
        mean(unlist(transitions.ml.3.u_FSW_PWID.comb[5,]))  +
        mean(unlist(transitions.ml.3.u_HET_PWID.comb[5,])) )
  withinVfrom_PWID.permuted.comb <- unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[7,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[5,]) +
        unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[5,])  +
        unlist(transitions.permuted.ml.3.u_HET_PWID.comb[5,]) )
  within_p_PWID.u.3 <- get_p_value(withinVfrom_PWID.observed.comb,
                                   withinVfrom_PWID.permuted.comb, tails = 1, H_direction = ">", scale0 = TRUE)


withinPWID_PValue.combined <- paste("Within vs from PWID (combined): ", round(mean(within_p_PWID.u.3), 3))
withinPWID_PValue.combined  
withinPWID_PValue <- paste(withinPWID_PValue.averaged, "\n", withinPWID_PValue.combined)
cat(withinPWID_PValue, file=paste0(save_path, "A1/A1_risk_ASR_ml_uniform.3.p_value.txt"))





# Between trait
### PWID & FSW (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_FSW.observed.comb <- mean(unlist(transitions.ml.3.u_FSW_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_FSW_PWID.comb[6,]))
  directional_PWID_FSW.permuted.comb <- unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[6,]))
  directional_p_PWID_FSW.u.3 <- get_p_value(directional_PWID_FSW.observed.comb,
                                   directional_PWID_FSW.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_FSW.combined <- paste("Directional (PWID & FSW), combined: ", round(mean(directional_p_PWID_FSW.u.3), 3))
directional_PWID_FSW.combined


### PWID & MSM (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_MSM.observed.comb <- mean(unlist(transitions.ml.3.u_MSM_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_MSM_PWID.comb[6,]))
  directional_PWID_MSM.permuted.comb <- unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[6,]))
  directional_p_PWID_MSM.u.3 <- get_p_value(directional_PWID_MSM.observed.comb,
                                   directional_PWID_MSM.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_MSM.combined <- paste("Directional (PWID & MSM), combined: ", round(mean(directional_p_PWID_MSM.u.3), 3))
directional_PWID_MSM.combined


### PWID & HET (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_HET.observed.comb <- mean(unlist(transitions.ml.3.u_HET_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_HET_PWID.comb[6,]))
  directional_PWID_HET.permuted.comb <- unlist(transitions.permuted.ml.3.u_HET_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_HET_PWID.comb[6,]))
  directional_p_PWID_HET.u.3 <- get_p_value(directional_PWID_HET.observed.comb,
                                   directional_PWID_HET.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_HET.combined <- paste("Directional (PWID & HET), combined: ", round(mean(directional_p_PWID_HET.u.3), 3))
directional_PWID_HET.combined





## Save all ##
risk_PValue <- paste(withinPWID_PValue.averaged, "\n", withinPWID_PValue.combined, "\n",
                     directional_PWID_MSM.combined, "\n", directional_PWID_MSM.combined, "\n", directional_PWID_HET.combined)
cat(risk_PValue, file=paste0(save_path, "C/C_risk_ASR_ml_uniform.3.p_value.txt"))
```  


### Drop objects
```{r drop C.3 vars}
#Note: for now, not dropping objects as these will be small compared to subtype A1
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
     pd.3.u, fit.3.u, ap.3.u,

    #transition counts - true
     transitions.ml.3.u,
    #transition counts - permuted
     transitions.permuted.ml.3.u,
     ml_summary.3.u,
     
    #Examples for plotting - true
     fit.3.u.example,
     ap.3.u.example,
     #Examples for plotting - permuted
     pd.3.u.resampled_example, pd.3.u.resampled_example.phylo,
     fit.3.u.resample_example,
     ap.3.u.resample_example, ap.3.u.resample_examples.list,
     nodestates.3.u.resample_example,
     resolved.3.u.resample_example,
    
    #plots
    transitions_plot.ml.3.u,
    
    #P-values
    withinVfrom_PWID.observed, withinVfrom_PWID.permuted, within_p_PWID.u.3)})
}
```




<br><br><br>




## ML - risk & region combined (.4)

### Count Transitions
```{r C.4 - Count Transitions - u, fig.width=10, fig.height=10, eval = C & run4}

###

# Uniform subsampling (.u)
pd.4.u <- lapply(trees.Uniform_riskregion, phylo_variable, metadata =  tree.hiv.meta, trait = "PWID_region.comb")

set.seed(1)
fit.4.u <- mapply(pml, trees.Uniform_riskregion, pd.4.u, SIMPLIFY = FALSE)
fit.4.u <- lapply(fit.4.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.4.u <- lapply(fit.4.u , ancestral.pml, type = "ml")
nodestates.ml.4.u <- lapply(ap.4.u, function(x) replicate(n_parsimony, resolve_ancestors(x, only_resolved = TRUE), simplify = FALSE))
ap.4.u[[1]] #CHECK site patterns (these should be alphabetical!)

transition_counts.ml.4.u <- mapply(function(x,y){
    lapply(x, function(z) { count_transitions2(z, tree = y)})
  }, nodestates.ml.4.u, trees.Uniform_riskregion, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){ #
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,2))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDCoast_PWIDCoast <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,3))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDCoast_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

transitions.ml.4.u_nonPWIDNairobi_PWIDCoast <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,3))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

transitions.ml.4.u_PWIDCoast_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))


#Visualize tree
plotAnc(trees.Uniform_riskregion[[1]], ap.4.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "PWID & Region combined - C (Uniform Subsampling)")
```

### Run permutations
```{r C.4 - permutations - u, eval = C & run4}

# Uniform subsampling
set.seed(2)
transition_counts.permuted.ml.4.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.4.u,
  trees.Uniform_riskregion, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,2))))})
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,3))))})
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,4))))})

transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,3))))})
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,4))))})

transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(3,4))))})


```


### Summary Table 

```{r C.4 - Summary table - u, eval = C & run4, results='asis'}

# Uniform subsampling:

##initialize and empty data frame to hold the transition counts between each group (for total tree)
riskregion.transitioncounts.u <- matrix(ncol = 4, nrow = 4)
colnames(riskregion.transitioncounts.u) <- c("nonPWIDCoast", "nonPWIDNairobi", "PWIDCoast", "PWIDNairobi")
rownames(riskregion.transitioncounts.u) <- c("nonPWIDCoast", "nonPWIDNairobi", "PWIDCoast", "PWIDNairobi")
#In the matrix, FROM is the column names and TO is the row names - verify this!

ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "nonPWID_Nairobi"), subtype = "C - nonPWIDCoast&nonPWIDNairobi",
                       binary_trait = FALSE)) %>%
  data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_nonPWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDCoast_nonPWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_nonPWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["nonPWIDNairobi", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$trait1to0))
riskregion.transitioncounts.u["nonPWIDCoast", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$within0)) #Also for within nonPWIDCoast
riskregion.transitioncounts.u["nonPWIDNairobi", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$within0)) #Also for within nonPWIDNairobi


ml_summary.4.u_nonPWIDCoast_PWIDCoast <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_PWIDCoast,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "PWID_Coast"), subtype = "C - nonPWIDCoast&PWIDCoast",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_PWIDCoast <- apply(ml_summary.4.u_nonPWIDCoast_PWIDCoast, 2, range) %>%
  as.data.frame()  # range
ml_summary_comb.4.u_nonPWIDCoast_PWIDCoast <- apply(ml_summary.4.u_nonPWIDCoast_PWIDCoast, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_PWIDCoast) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDCoast", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$trait1to0))
riskregion.transitioncounts.u["PWIDCoast", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$within1)) #Also for within PWIDCoast


ml_summary.4.u_nonPWIDCoast_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "PWID_Nairobi"), subtype = "C - nonPWIDCoast&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$trait1to0))
riskregion.transitioncounts.u["PWIDNairobi", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$within1)) #Also for within PWIDNairobi

ml_summary.4.u_nonPWIDNairobi_PWIDCoast <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDNairobi_PWIDCoast,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Nairobi", "PWID_Coast"), subtype = "C - nonPWIDNairobi&PWIDCoast",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDNairobi_PWIDCoast <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDNairobi_PWIDCoast <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDNairobi_PWIDCoast) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDCoast", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDCoast$trait0to1))
riskregion.transitioncounts.u["nonPWIDNairobi", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDCoast$trait1to0))

ml_summary.4.u_nonPWIDNairobi_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("PWID_Nairobi", "PWID_Nairobi"), subtype = "C- nonPWIDNairobi&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDNairobi_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDNairobi_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDNairobi_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDNairobi", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi$trait1to0))

ml_summary.4.u_PWIDCoast_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_PWIDCoast_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("PWID_Coast", "PWID_Nairobi"), subtype = "C - PWIDCoast&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_PWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_PWIDCoast_PWIDNairobi, 2, range) %>%
  as.data.frame() # range
ml_summary_comb.4.u_PWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_PWIDCoast_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_PWIDCoast_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_PWIDCoast_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["PWIDCoast", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_PWIDCoast_PWIDNairobi$trait1to0))


# Combine into 1 table
ml_summary.4.u <- rbind(ml_summary_comb.4.u_nonPWIDCoast_nonPWIDNairobi,
                              ml_summary_comb.4.u_nonPWIDCoast_PWIDCoast) %>%
  rbind(ml_summary_comb.4.u_nonPWIDCoast_PWIDNairobi) %>%
  rbind(ml_summary_comb.4.u_nonPWIDNairobi_PWIDCoast) %>%
  rbind(ml_summary_comb.4.u_nonPWIDNairobi_PWIDNairobi) %>%
  rbind(ml_summary_comb.4.u_PWIDCoast_PWIDNairobi)

#Print fancy table:
fancify_table(ml_summary.4.u, title = "SHARP ML - uniform subsampling") %T>% print(.) %>%
  save_kable(paste0(save_path, "C/C_PWIDxregion_ASR_ml_uniform_nonPWIDCoast_PWIDCoast_summary_table_4.html"))
```


### Save Raw Result Data
```{r C.4 - save backup data - u, eval = C & run4 & save_backup}
saveRDS(transition_counts.ml.4.u, paste0(save_path, "raw_results/transition_counts.ml.C.4.u.Rmd"))
saveRDS(transition_counts.permuted.ml.4.u, paste0(save_path, "raw_results/transition_counts.permuted.ml.C.4.u.Rmd"))

saveRDS(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, paste0(save_path, "raw_results/ml_summary.C.4.u_nonPWIDCoast_nonPWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDCoast_PWIDCoast, paste0(save_path, "raw_results/ml_summary.C.4.u_nonPWIDCoast_PWIDCoast.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.C.4.u_nonPWIDCoast_PWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, paste0(save_path, "raw_results/ml_summary.C.4.u_nonPWIDNairobi_PWIDCoast.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.C.4.u_nonPWIDNairobi_PWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_PWIDCoast_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.C.4.u_PWIDCoast_PWIDNairobi.Rmd"))
```



#### Get a p-value that combines all the resamples (instead of averaging the p-values for each resample)

```{r C.4 - p-value based on all resamples - u, eval = C & run4}


## average p -value ##

# within trait
within_p_nonPWIDCoast.u <- c()
for(i in 1:n_subsamples_C){
  withinVfrom_nonPWIDCoast.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][8,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][6,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][6,]))  +
        mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][6,])) )
  withinVfrom_nonPWIDCoast.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][8,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][6,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][6,])  +
        unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][6,]) )
  
  within_p_nonPWIDCoast.u.averaged <- append(within_p_nonPWIDCoast.u, get_p_value(withinVfrom_nonPWIDCoast.observed, withinVfrom_nonPWIDCoast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_nonPWIDNairobi.u <- c()
for(i in 1:n_subsamples_C){
  withinVfrom_nonPWIDNairobi.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][6,]))  +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][6,])) )
  withinVfrom_nonPWIDNairobi.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][6,])  +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][6,]) )
  
  within_p_nonPWIDNairobi.u.averaged <- append(within_p_nonPWIDCoast.u, get_p_value(withinVfrom_nonPWIDNairobi.observed, withinVfrom_nonPWIDNairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_PWIDCoast.u <- c()
for(i in 1:n_subsamples_C){
  withinVfrom_PWIDCoast.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][5,]))  +
        mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi[[i]][6,])) )
  withinVfrom_PWIDCoast.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][5,])  +
        unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi[[i]][6,]) )
  
  within_p_PWIDCoast.u.averaged <- append(within_p_PWIDCoast.u, get_p_value(withinVfrom_PWIDCoast.observed, withinVfrom_PWIDCoast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_PWIDNairobi.u <- c()
for(i in 1:n_subsamples_C){
  withinVfrom_PWIDNairobi.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][5,]))  +
        mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi[[i]][5,])) )
  withinVfrom_PWIDNairobi.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][5,])  +
        unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi[[i]][5,]) )
  
  within_p_PWIDNairobi.u.averaged <- append(within_p_PWIDCoast.u, get_p_value(withinVfrom_PWIDNairobi.observed, withinVfrom_PWIDNairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

withinTrait_PValues.4.u.average <- paste("Within non-PWID Coast (Average):", round(mean(within_p_nonPWIDCoast.u.averaged),3),
      "\nWithin non-PWID Nairobi (Average):", round(mean(within_p_nonPWIDNairobi.u.averaged),3),
      "\nWithin PWID Coast (Average):", round(mean(within_p_PWIDCoast.u.averaged),3),
      "\nWithin PWID Nairobi (Average):", round(mean(within_p_PWIDNairobi.u.averaged),3))
cat(withinTrait_PValues.4.u.average)





## combined p -values (combine subtrees then calculate 1 p-value) ##

# combine subtrees - observed
transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDNairobi_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_PWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)

# combine subtrees - permuted
transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb <- 
  matrix(do.call(cbind,transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi),nrow = 8, byrow= FALSE)


# Get p-values
withinVfrom_nonPWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [8,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,]))  +
      mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,])) )
withinVfrom_nonPWIDCoast.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [8,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,])  +
      unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,]) )
  
  within_p_nonPWIDCoast.u.comb  <- get_p_value(withinVfrom_nonPWIDCoast.observed.comb , withinVfrom_nonPWIDCoast.permuted.comb ,
                                         tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_nonPWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,]))  +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb[6,])) )
withinVfrom_nonPWIDNairobi.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,])  +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,]) )
  
  within_p_nonPWIDNairobi.u.comb  <- get_p_value(withinVfrom_nonPWIDNairobi.observed.comb , withinVfrom_nonPWIDNairobi.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,]))  +
      mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,])) )
withinVfrom_PWIDCoast.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,])  +
      unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,]) )
  
  within_p_PWIDCoast.u.comb  <- get_p_value(withinVfrom_PWIDCoast.observed.comb , withinVfrom_PWIDCoast.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,]))  +
      mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,])) )
withinVfrom_PWIDNairobi.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,])  +
      unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,]) )
  
  within_p_PWIDNairobi.u.comb  <- get_p_value(withinVfrom_PWIDNairobi.observed.comb , withinVfrom_PWIDNairobi.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinTrait_PValues.4.u.comb <- paste("Within non-PWID Coast (Combined):", round(mean(within_p_nonPWIDCoast.u.comb ),3),
      "\nWithin non-PWID Nairobi (Combined):", round(within_p_nonPWIDNairobi.u.comb, 3),
      "\nWithin PWID Coast (Combined):", round(within_p_PWIDCoast.u.comb, 3),
      "\nWithin PWID Nairobi (Combined):", round(within_p_PWIDNairobi.u.comb, 3))
cat(withinTrait_PValues.4.u.comb)







## Directional 

nonPWIDCoast_V_nonPWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,]))
nonPWIDCoast_V_nonPWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,])
  
nonPWIDCoast_V_nonPWIDNairobi.u.comb  <-get_p_value(nonPWIDCoast_V_nonPWIDNairobi.observed.comb,
                                                     nonPWIDCoast_V_nonPWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)



nonPWIDCoast_V_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,]))
nonPWIDCoast_V_PWIDCoast.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,])
  
nonPWIDCoast_V_PWIDCoast.u.comb  <-get_p_value(nonPWIDCoast_V_PWIDCoast.observed.comb,
                                                     nonPWIDCoast_V_PWIDCoast.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDCoast_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,]))
nonPWIDCoast_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,])
  
nonPWIDCoast_V_PWIDNairobi.u.comb  <-get_p_value(nonPWIDCoast_V_PWIDNairobi.observed.comb,
                                                     nonPWIDCoast_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDNairobi_V_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,]))
nonPWIDNairobi_V_PWIDCoast.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,])
  
nonPWIDNairobi_V_PWIDCoast.u.comb  <-get_p_value(nonPWIDNairobi_V_PWIDCoast.observed.comb,
                                                     nonPWIDNairobi_V_PWIDCoast.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDNairobi_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,]))
nonPWIDNairobi_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,])
  
nonPWIDNairobi_V_PWIDNairobi.u.comb  <-get_p_value(nonPWIDNairobi_V_PWIDNairobi.observed.comb,
                                                     nonPWIDNairobi_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


PWIDCoast_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,]))
PWIDCoast_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,])
  
PWIDCoast_V_PWIDNairobi.u.comb  <-get_p_value(PWIDCoast_V_PWIDNairobi.observed.comb,
                                                     PWIDCoast_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


directional_PValues.4.u.comb <- paste(
  "non-PWID Coast V non-PWID Nairobi (Combined):", round(nonPWIDCoast_V_nonPWIDNairobi.u.comb, 3),
  "\nnon-PWID Coast V PWID Coast (Combined):", round(nonPWIDCoast_V_PWIDCoast.u.comb, 3),
  "\nnon-PWID Coast V PWID Nairobi (Combined):", round(nonPWIDCoast_V_PWIDNairobi.u.comb, 3),
  "\nnon-PWID Nairobi V PWID Coast (Combined):", round(nonPWIDNairobi_V_PWIDCoast.u.comb, 3),
  "\nnon-PWID Nairobi V PWID Nairobi (Combined):", round(nonPWIDNairobi_V_PWIDNairobi.u.comb, 3),
  "\nPWID Coast V PWID Nairobi (Combined):", round(nonPWIDNairobi_V_PWIDNairobi.u.comb,3 )
       )
cat(directional_PValues.4.u.comb)


## Save all
PValues.4.u <- paste(withinTrait_PValues.4.u.average, "\n\n", withinTrait_PValues.4.u.comb, "\n\n",
                             directional_PValues.4.u.comb)

cat(PValues.4.u, file = paste0(save_path, "C/C_PWIDxregion_ASR_ml_uniform.4.p_value.txt"))
```



#### Illustration: different permutations
Not used in analysis: This is to show what the resampled trees (ie. random region assignments) look like
```{r C.4 - permutation illustration - u, fig.width=10, fig.height=30, eval = C & run4}
# Uniform subsampling
png(paste0(save_path, "C/C_PWIDxregion_ASR_ml_uniform_subsamp_permutation_plots_4.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)

for(i in 1:4){
  pd.4.u.resampled_example <- resample_trait(pd.4.u[[1]])
  fit.4.u.resample_example <- pml(trees.Uniform_riskregion[[1]], pd.4.u.resampled_example)
  ap.4.u.resample_example <- ancestral.pml(fit.4.u.resample_example, "ml")
  
  plotAnc(trees.Uniform_riskregion[[1]], ap.4.u.resample_example, cex = 0.4, show.tip.label = FALSE)
}

dev.off()

#Also print to screen:
knitr::include_graphics(paste0(save_path, "C/C_PWIDxregion_ASR_ml_uniform_subsamp_permutation_plots_4.png"))

par(mfrow=c(1,1))
```


### Illustration: Plot transitions counts against permutations (large tree - ML ASR - risk)  
Not used in analysis
```{r C.4 - plot transitions - u, fig.width = 10, fig.height = 15, eval = FALSE}
# Uniform subsampling
transitions_plot.ml.4.u_PWIDCoast_PWIDNairobi <- SupressWarnings(plot_true_vs_permutations(transitions.df = transitions.ml.4.u_PWIDCoast_PWIDNairobi[[1]], transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[1]]))
transitions_plot.ml.4.u_PWIDCoast_PWIDNairobi

ggsave(paste0(save_path, "C/C_PWIDxregion_ASR_ml_subsamp_uniform_permtuations_PWIDCoast_PWIDNairobi_4.png"), transitions_plot.ml.4.u_PWIDCoast_PWIDNairobi, width = 15, height = 10, units = "in", dpi = 300)
```  





## Plot flow diagrams (from region & risk combined var)
```{r C.4 - flow diagrams - u, eval = C & run4}


# Uniform subsampling

#FROM is columns, TO is rows

riskregion.transitioncounts.u  <- round(riskregion.transitioncounts.u, 1)

riskregion.transitioncounts.u <- ifelse(is.na(riskregion.transitioncounts.u), 0 , riskregion.transitioncounts.u) #replace NA values with 0 - otherwise grey function won't work


# Set arrow widths as transition proportionate to pop size
transitions.colorgrad <- gray(1- (riskregion.transitioncounts.u/max(riskregion.transitioncounts.u, na.rm = TRUE))) %>% #This gives each value in the matrix as a percent of the max value (then inverses because lower values are darker) and then gets the corresponding greyscale level
  matrix(nrow = nrow(riskregion.transitioncounts.u), ncol = ncol(riskregion.transitioncounts.u), byrow = FALSE)

#Check - these should match up 
riskregion.transitioncounts.u
grid.raster(as.raster(transitions.colorgrad), width = 1, height = 1, interpolate = FALSE)


png(filename = paste0(save_path, "C/C_PWIDxregion_uniform_flow_diagram_4.png"))
  plotmat(riskregion.transitioncounts.u, pos = c(2, 2), 
          arr.width = 0.4, arr.type = "triangle", arr.col = transitions.colorgrad,
          arr.lcol = transitions.colorgrad, dtext = 0.25,
          self.cex = 0.5, self.shiftx = c(-0.05,0.05,-0.05,0.05),
          self.shifty = c(0.025,0.025,-0.025,-0.025), 
          box.lwd = 1, box.size = .05, box.type = "square",
          box.prop = .5, box.cex = .8, curve = 0.1, shadow.size = 0, relsize = 1.2,
          box.col = c("pink", "lightblue", "green", "yellow"))
dev.off()


```



### Drop objects
```{r drop C.4 vars, eval = FALSE}
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
     pd.4.u, fit.4.u, ap.4.u,

    #transition counts - true
     transitions.ml.4.u,
    #transition counts - permuted
     transitions.permuted.ml.4.u,
     ml_summary.4.u,
     
    #Examples for plotting - true
     fit.4.u.example, ap.4.u.example,
     #Examples for plotting - permuted
     pd.4.u.resampled_example, pd.4.u.resampled_example.phylo,
     fit.4.u.resample_example,
     ap.4.u.resample_example, ap.4.u.resample_examples.list,
     nodestates.4.u.resample_example, 
     resolved.4.u.resample_example,
    
    #plots
    transitions_plot.ml.4.u,
    
    #P-values
    within_p_nonPWIDCoast.u, withinVfrom_nonPWIDCoast.observed, withinVfrom_nonPWIDCoast.permuted,
    within_p_nonPWIDNairobi.u, withinVfrom_nonPWIDNairobi.observed, withinVfrom_nonPWIDNairobi.permuted,
    within_p_PWIDCoast.u, withinVfrom_PWIDCoast.observed, withinVfrom_PWIDCoast.permuted,
    within_p_PWIDNairobi.u, withinVfrom_PWIDNairobi.observed, withinVfrom_PWIDNairobi.permuted)})
}
```


# Drop all files (but keep functions and constants)
```{r drop C objects, eval = drop_ASR}
rm(list = setdiff(setdiff(ls(), lsf.str()),
                  #Keep these:
                  c("save_path", "drop_ASR", "write_perms", "D",
                    "SHARP_seq_names", 
                    "n_parsimony", "n_permutations", "n_subsamples_C", "n_subsamples_D")))
```



















# SUBTYPE D



## Read in data

### tree data
```{r D - read in tree data, eval = D}
# SHARP and published
tree.hiv <- readRDS("../HIV/tree.hiv.CN.D.rds") #tree data object
tree.hiv.meta <- readRDS("../HIV/meta_tree.hiv.CN.D.rds") #metadata with info about tree 

```  

### sequence lists
```{r D - read in seq lists, eval = D}
# Single
Uniform_region.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_region.D.seqs.rds")
Uniform_risk.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_risk.D.seqs.rds")
Uniform_regionrisk.seqs <- readRDS("../HIV/subsampled_seq_lists/Uniform_regionrisk.D.seqs.rds")

# Lists
Uniform_region.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_region.D.seqs.list.rds")
Uniform_risk.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_risk.D.seqs.list.rds")
Uniform_regionrisk.seqs.list <- readRDS("../HIV/subsampled_seq_lists/Uniform_regionrisk.D.seqs.list.rds")

```


TO DO: add Uniform_region_SHARP.seqs


### check that trees are binary (bifurcating) and rooted  
```{r D - check binary and bifurcating, eval = D}
is.binary.phylo(tree.hiv)
is.rooted.phylo(tree.hiv) #It's actually ok that this is FALSE
```


## Extract trees


### Downsample trees - Uniform subsampling

#### Downsample
```{r D - downsampling trees - SHARP}
# downsample trees based on pre-specified filters
### First specify leaves NOT in the filter (thus the X_)
X_Uniform_region.seqs.list <-
  lapply(Uniform_region.seqs.list[1:n_subsamples_D],  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
X_Uniform_risk.seqs.list <-
  lapply(Uniform_risk.seqs.list[1:n_subsamples_D],  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})
X_Uniform_riskregion.seqs.list <-
  lapply(Uniform_regionrisk.seqs.list[1:n_subsamples_D],  function(x) {
    tree.hiv$tip.label[!(tree.hiv$tip.label %in% x)]})



# Drop leaves not in the filter
trees.Uniform_region <- lapply(X_Uniform_region.seqs.list, function(x){ape::drop.tip(tree.hiv, x)})
trees.Uniform_risk <- lapply(X_Uniform_risk.seqs.list, function(x){ape::drop.tip(tree.hiv, x)})
trees.Uniform_riskregion <- lapply(X_Uniform_riskregion.seqs.list, function(x){ape::drop.tip(tree.hiv, x)})


# Count number of branches (goes into ARS tables)
nrow(trees.Uniform_risk[[1]]$edge)
nrow(trees.Uniform_riskregion[[1]]$edge)
```





## ANCESTRAL STATE RESCONSTRUCTION


## ML - risk (.3)

### Count Transitions

```{r D.3 - Count Transitions - u, fig.width=10, fig.height=10, eval = D & run3}
# Uniform subsampling (.u)
pd.3.u <- lapply(trees.Uniform_risk, phylo_variable, metadata =  tree.hiv.meta, trait = "risk4.F")

set.seed(1)
fit.3.u <- mapply(pml, trees.Uniform_risk, pd.3.u, SIMPLIFY = FALSE)
fit.3.u <- lapply(fit.3.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.3.u <- lapply(fit.3.u , ancestral.pml, type = "ml")
nodestates.ml.3.u <- lapply(ap.3.u, function(x) replicate(n_parsimony, resolve_ancestors(x, only_resolved = TRUE), simplify = FALSE))
ap.3.u #CHECK site patterns (these should be alphabetical!)

transition_counts.ml.3.u <- mapply(function(x,y){
    lapply(x, function(z) { count_transitions2(z, tree = y)})
  }, nodestates.ml.3.u, trees.Uniform_risk, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.ml.3.u_FSW_PWID <- lapply(transition_counts.ml.3.u, function(x){ #
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,4))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.3.u_HET_PWID <- lapply(transition_counts.ml.3.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,4))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.3.u_MSM_PWID <- lapply(transition_counts.ml.3.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

#Visualize tree
plotAnc(trees.Uniform_risk[[1]], ap.3.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "Risk Population - C (Uniform Subsampling)")
```

### Run permutations
```{r D.3 - permutations - u, eval = D & run3}
# Uniform subsampling
set.seed(2)
transition_counts.permuted.ml.3.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.3.u,
  trees.Uniform_risk, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.permuted.ml.3.u_FSW_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,4))))})
transitions.permuted.ml.3.u_HET_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,4))))})
transitions.permuted.ml.3.u_MSM_PWID <- lapply(transition_counts.permuted.ml.3.u, function(x) { t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(3,4))))})
```


### Summary Table 

```{r D.3 - Summary table - u, eval = D & run3, results='asis'}
# Uniform subsampling:
ml_summary.3.u_FSW_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_FSW_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_FSW_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("FSW", "PWID"),
                       subtype = "D - FSW&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_FSW_PWID <- apply(ml_summary.3.u_FSW_PWID, 2, range) %>% as.data.frame
ml_summary.3.u_FSW_PWID <- apply(ml_summary.3.u_FSW_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_FSW_PWID) #add mean

ml_summary.3.u_HET_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_HET_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_HET_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("HET", "PWID"),
                       subtype = "D - HET&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_HET_PWID <- apply(ml_summary.3.u_HET_PWID, 2, range) %>% as.data.frame #range
ml_summary.3.u_HET_PWID <- apply(ml_summary.3.u_HET_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_HET_PWID) #add mean

ml_summary.3.u_MSM_PWID <- mapply(transitions_summary_table,
       tree = trees.Uniform_risk,
       transitions.df = transitions.ml.3.u_MSM_PWID,
       transitions.permuted =  transitions.permuted.ml.3.u_MSM_PWID,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "risk4.F", trait_cats = c("MSM", "PWID"),
                       subtype = "D - MSM&PWID", binary_trait = FALSE)) %>%
  as.data.frame() %>% t()
ml_summary_range.3.u_MSM_PWID <- apply(ml_summary.3.u_MSM_PWID, 2, range) %>% as.data.frame #range
ml_summary.3.u_MSM_PWID <- apply(ml_summary.3.u_MSM_PWID, 2, get_subtree_means) %>% as.data.frame() %>% t() %>% rbind(ml_summary_range.3.u_MSM_PWID) #add mean



# Combine into 1 table
ml_summary.3.u <- rbind(ml_summary.3.u_FSW_PWID, ml_summary.3.u_HET_PWID) %>%
  rbind(ml_summary.3.u_MSM_PWID)

#Print fancy table:
fancify_table(ml_summary.3.u, title = "SHARP ML - uniform subsampling", trait0 = "FSW, HET, MSM", trait1 = "PWID, PWID, PWID") %T>% print(.) %>%
  save_kable(paste0(save_path, "D/D_risk_ASR_ml_uniform_summary_table_3.html"))
```



### Save Raw Result Data

```{r D.3 - save backup data - p, eval = D & run3 & run_propotionate & save_backup}
saveRDS(transition_counts.ml.3.u, paste0(save_path, "raw_results/transition_counts.ml.D.3.u.Rmd"))
saveRDS(transition_counts.permuted.ml.3.u, paste0(save_path, "raw_results/transition_counts.permuted.ml.D.3.u.Rmd"))

saveRDS(ml_summary.3.u_FSW_PWID, paste0(save_path, "raw_results/ml_summary.D.3.u_FSW_PWID.Rmd"))
saveRDS(ml_summary.3.u_MSM_PWID, paste0(save_path, "raw_results/ml_summary.D.3.u_MSM_PWID.Rmd"))
saveRDS(ml_summary.3.u_HET_PWID, paste0(save_path, "raw_results/ml_summary.D.3.u_HET_PWID.Rmd"))
```



#### Get within-group P value
Within group p-value is a ratio of transitions within the group vs all transitions from the group. Since summary table only uses the binary comparisons, we calculate this p-value separately

```{r D.3 - p-value based on all resamples - u, eval = D & run3}
# Within trait
### PWID (average over subtrees)
within_p_PWID.u.3 <- c()
for(i in 1:n_subsamples_D){
  withinVfrom_PWID.observed <- mean(unlist(transitions.ml.3.u_MSM_PWID[[i]][7,])) / 
    ( mean(unlist(transitions.ml.3.u_MSM_PWID[[i]][5,])) +
        mean(unlist(transitions.ml.3.u_FSW_PWID[[i]][5,]))  +
        mean(unlist(transitions.ml.3.u_HET_PWID[[i]][5,])) )
  withinVfrom_PWID.permuted <- unlist(transitions.permuted.ml.3.u_MSM_PWID[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID[[i]][5,]) +
        unlist(transitions.permuted.ml.3.u_FSW_PWID[[i]][5,])  +
        unlist(transitions.permuted.ml.3.u_HET_PWID[[i]][5,]) )
  
  within_p_PWID.u.3 <- append(within_p_PWID.u.3, get_p_value(withinVfrom_PWID.observed, withinVfrom_PWID.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

withinPWID_PValue.averaged <- paste("Within vs from PWID (averaged): ", round(mean(within_p_PWID.u.3), 3))
withinPWID_PValue.averaged 


### PWID (combine subtrees & calc 1 p-value)

#Combine across subtrees
transitions.ml.3.u_MSM_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_MSM_PWID), nrow = 8, byrow= FALSE)
#do.call(cbind, lapply(transitions.ml.3.u_FSW_PWID, as.data.frame))
transitions.ml.3.u_FSW_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_FSW_PWID), nrow = 8, byrow= FALSE)
transitions.ml.3.u_HET_PWID.comb <- matrix(do.call(cbind, transitions.ml.3.u_HET_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_MSM_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_MSM_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_FSW_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_FSW_PWID), nrow = 8, byrow= FALSE)
transitions.permuted.ml.3.u_HET_PWID.comb <- matrix(do.call(cbind, transitions.permuted.ml.3.u_HET_PWID), nrow = 8, byrow= FALSE)

#Get P-value
  withinVfrom_PWID.observed.comb <- mean(unlist(transitions.ml.3.u_MSM_PWID.comb[7,])) / 
    ( mean(unlist(transitions.ml.3.u_MSM_PWID.comb[5,])) +
        mean(unlist(transitions.ml.3.u_FSW_PWID.comb[5,]))  +
        mean(unlist(transitions.ml.3.u_HET_PWID.comb[5,])) )
  withinVfrom_PWID.permuted.comb <- unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[7,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[5,]) +
        unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[5,])  +
        unlist(transitions.permuted.ml.3.u_HET_PWID.comb[5,]) )
  within_p_PWID.u.3 <- get_p_value(withinVfrom_PWID.observed.comb,
                                   withinVfrom_PWID.permuted.comb, tails = 1, H_direction = ">", scale0 = TRUE)


withinPWID_PValue.combined <- paste("Within vs from PWID (combined): ", round(mean(within_p_PWID.u.3), 3))
withinPWID_PValue.combined  
withinPWID_PValue <- paste(withinPWID_PValue.averaged, "\n", withinPWID_PValue.combined)
cat(withinPWID_PValue, file=paste0(save_path, "A1/A1_risk_ASR_ml_uniform.3.p_value.txt"))





# Between trait
### PWID & FSW (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_FSW.observed.comb <- mean(unlist(transitions.ml.3.u_FSW_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_FSW_PWID.comb[6,]))
  directional_PWID_FSW.permuted.comb <- unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_FSW_PWID.comb[6,]))
  directional_p_PWID_FSW.u.3 <- get_p_value(directional_PWID_FSW.observed.comb,
                                   directional_PWID_FSW.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_FSW.combined <- paste("Directional (PWID & FSW), combined: ", round(mean(directional_p_PWID_FSW.u.3), 3))
directional_PWID_FSW.combined


### PWID & MSM (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_MSM.observed.comb <- mean(unlist(transitions.ml.3.u_MSM_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_MSM_PWID.comb[6,]))
  directional_PWID_MSM.permuted.comb <- unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_MSM_PWID.comb[6,]))
  directional_p_PWID_MSM.u.3 <- get_p_value(directional_PWID_MSM.observed.comb,
                                   directional_PWID_MSM.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_MSM.combined <- paste("Directional (PWID & MSM), combined: ", round(mean(directional_p_PWID_MSM.u.3), 3))
directional_PWID_MSM.combined


### PWID & HET (combine subtrees & calc 1 p-value)

#Combine across subtrees
  directional_PWID_HET.observed.comb <- mean(unlist(transitions.ml.3.u_HET_PWID.comb[5,])) / 
     mean(unlist(transitions.ml.3.u_HET_PWID.comb[6,]))
  directional_PWID_HET.permuted.comb <- unlist(transitions.permuted.ml.3.u_HET_PWID.comb[5,]) / 
    ( unlist(transitions.permuted.ml.3.u_HET_PWID.comb[6,]))
  directional_p_PWID_HET.u.3 <- get_p_value(directional_PWID_HET.observed.comb,
                                   directional_PWID_HET.permuted.comb, tails = 2, scale0 = TRUE)


directional_PWID_HET.combined <- paste("Directional (PWID & HET), combined: ", round(mean(directional_p_PWID_HET.u.3), 3))
directional_PWID_HET.combined





## Save all ##
risk_PValue <- paste(withinPWID_PValue.averaged, "\n", withinPWID_PValue.combined, "\n",
                     directional_PWID_MSM.combined, "\n", directional_PWID_MSM.combined, "\n", directional_PWID_HET.combined)
cat(risk_PValue, file=paste0(save_path, "D/D_risk_ASR_ml_uniform.3.p_value.txt"))
```


#### Illustration: different permutations 
Not used in analysis: This is to show what the resampled trees (ie. random region assignments) look like
```{r , D.3 permutation illustration - u, fig.width=10, fig.height=20, eval = D & run3}
# Uniform subsampling
png(paste0(save_path, "D/D_risk_ASR_ml_uniform_subsamp_permutation_plots_3.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)

for(i in 1:4){
  pd.3.u.resampled_example <- resample_trait(pd.3.u[[1]])
  fit.3.u.resample_example <- pml(trees.Uniform_risk[[1]], pd.3.u.resampled_example)
  ap.3.u.resample_example <- ancestral.pml(fit.3.u.resample_example, "ml")
  
  plotAnc(root.phylo(trees.Uniform_risk[[1]], 1), ap.3.u.resample_example, cex = 0.3, show.tip.label = FALSE)
}

dev.off()

#Also print to screen:
knitr::include_graphics(paste0(save_path, "D/D_risk_ASR_ml_uniform_subsamp_permutation_plots_3.png"))

par(mfrow=c(1,1))
```

TO DO: pick a logical root for better visualization.  



### Illustration: Plot transitions counts against permutations 
Not doing this for D subtype because it takes a long time and already did for A1 and C


### Drop objects
```{r drop D.3 vars}
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
     pd.3.u, fit.3.u, ap.3.u,

    #transition counts - true
     transitions.ml.3.u,
    #transition counts - permuted
     transitions.permuted.ml.3.u,
     ml_summary.3.u,
     
    #Examples for plotting - true
     fit.3.u.example,
     ap.3.u.example,
     #Examples for plotting - permuted
     pd.3.u.resampled_example, pd.3.u.resampled_example.phylo,
     fit.3.u.resample_example,
     ap.3.u.resample_example, ap.3.u.resample_examples.list,
     nodestates.3.u.resample_example,
     resolved.3.u.resample_example,
    
    #plots
    transitions_plot.ml.3.u,
  
    #P-values
    withinVfrom_PWID.observed, withinVfrom_PWID.permuted, within_p_PWID.u.3)})
}
```




<br><br><br>




## ML - risk & region combined (.4)

### Count Transitions
```{r D.4 - Count Transitions - u, fig.width=10, fig.height=10, eval = D & run4}

###

# Uniform subsampling (.u)
pd.4.u <- lapply(trees.Uniform_riskregion, phylo_variable, metadata =  tree.hiv.meta, trait = "PWID_region.comb")

set.seed(1)
fit.4.u <- mapply(pml, trees.Uniform_riskregion, pd.4.u, SIMPLIFY = FALSE)
fit.4.u <- lapply(fit.4.u , optim.pml, optEdge = FALSE, optRate=TRUE, 
                    control = pml.control(trace=0)) 
ap.4.u <- lapply(fit.4.u , ancestral.pml, type = "ml")
nodestates.ml.4.u <- lapply(ap.4.u, function(x) replicate(n_parsimony, resolve_ancestors(x, only_resolved = TRUE), simplify = FALSE))
ap.4.u[[1]] #CHECK site patterns (these should be alphabetical!)

transition_counts.ml.4.u <- mapply(function(x,y){
    lapply(x, function(z) { count_transitions2(z, tree = y)})
  }, nodestates.ml.4.u, trees.Uniform_riskregion, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){ #
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,2))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDCoast_PWIDCoast <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(1,3))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDCoast_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

transitions.ml.4.u_nonPWIDNairobi_PWIDCoast <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,3))})
  }) %>% lapply(function(x) do.call(cbind, x))
transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(2,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

transitions.ml.4.u_PWIDCoast_PWIDNairobi <- lapply(transition_counts.ml.4.u, function(x){
    lapply(x, function(z) { summarize_transitions(z, categories_0_1 = c(3,4))})
  }) %>% lapply(function(x) do.call(cbind, x))

#Visualize tree
plotAnc(trees.Uniform_riskregion[[1]], ap.4.u[[1]], cex = 0.25, show.tip.label = FALSE,
        main = "PWID & Region combined - D (Uniform Subsampling)")
```

### Run permutations
```{r D.4 - permutations - u, eval = D & run4}

# Uniform subsampling
set.seed(2)
transition_counts.permuted.ml.4.u <- mapply(
  function(x, y)
    replicate(
      n_permutations,
      permute_tree(pd = x,
                   tree = y, parsimony_method = "ml"), simplify = FALSE),
  pd.4.u,
  trees.Uniform_riskregion, SIMPLIFY = FALSE)

#Get counts for different pairs of key pops
transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,2))))})
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,3))))})
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(1,4))))})

transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,3))))})
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(2,4))))})

transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi <- lapply(transition_counts.permuted.ml.4.u, function(x) {
  t(do.call(rbind, lapply(x, mean_transitionsXparsimony, categories_0_1 = c(3,4))))})

```


### Summary Table 

```{r D.4 - Summary table - u, eval = D & run4, results='asis'}

# Uniform subsampling:

##initialize and empty data frame to hold the transition counts between each group (for total tree)
riskregion.transitioncounts.u <- matrix(ncol = 4, nrow = 4)
colnames(riskregion.transitioncounts.u) <- c("nonPWIDCoast", "nonPWIDNairobi", "PWIDCoast", "PWIDNairobi")
rownames(riskregion.transitioncounts.u) <- c("nonPWIDCoast", "nonPWIDNairobi", "PWIDCoast", "PWIDNairobi")
#In the matrix, FROM is the column names and TO is the row names - verify this!



ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "nonPWID_Nairobi"), subtype = "D - nonPWIDCoast&nonPWIDNairobi",
                       binary_trait = FALSE)) %>%
  data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_nonPWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDCoast_nonPWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_nonPWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["nonPWIDNairobi", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$trait1to0))
riskregion.transitioncounts.u["nonPWIDCoast", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$within0)) #also add the within nonPWID_Coast value
riskregion.transitioncounts.u["nonPWIDNairobi", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi$within1)) #also add the within nonPWID_Nairobi value

ml_summary.4.u_nonPWIDCoast_PWIDCoast <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_PWIDCoast,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "PWID_Coast"), subtype = "D - nonPWIDCoast&PWIDCoast",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_PWIDCoast <- apply(ml_summary.4.u_nonPWIDCoast_PWIDCoast, 2, range) %>%
  as.data.frame()  # range
ml_summary_comb.4.u_nonPWIDCoast_PWIDCoast <- apply(ml_summary.4.u_nonPWIDCoast_PWIDCoast, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_PWIDCoast) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDCoast", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$trait1to0))
riskregion.transitioncounts.u["PWIDCoast", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDCoast$within1)) #also add the within PWID_Coast value

ml_summary.4.u_nonPWIDCoast_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDCoast_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Coast", "PWID_Nairobi"), subtype = "D - nonPWIDCoast&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDCoast_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "nonPWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDCoast", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$trait1to0))
riskregion.transitioncounts.u["PWIDNairobi", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDCoast_PWIDNairobi$within1)) #also add the within PWID_Nairobi value


ml_summary.4.u_nonPWIDNairobi_PWIDCoast <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDNairobi_PWIDCoast,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("nonPWID_Nairobi", "PWID_Coast"), subtype = "D - nonPWIDNairobi&PWIDCoast",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDNairobi_PWIDCoast <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDNairobi_PWIDCoast <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDNairobi_PWIDCoast) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDCoast", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDCoast$trait0to1))
riskregion.transitioncounts.u["nonPWIDNairobi", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDCoast$trait1to0))

ml_summary.4.u_nonPWIDNairobi_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("PWID_Nairobi", "PWID_Nairobi"), subtype = "D - nonPWIDNairobi&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_nonPWIDNairobi_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, 2, range) %>% as.data.frame() # range
ml_summary_comb.4.u_nonPWIDNairobi_PWIDNairobi <- apply(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_nonPWIDNairobi_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "nonPWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["nonPWIDNairobi", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi$trait1to0))



ml_summary.4.u_PWIDCoast_PWIDNairobi <- mapply(transitions_summary_table,
       tree = trees.Uniform_riskregion,
       transitions.df = transitions.ml.4.u_PWIDCoast_PWIDNairobi,
       transitions.permuted =  transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi,
       MoreArgs = list(meta.tree = tree.hiv.meta, trait = "PWID_region.comb",
                       trait_cats = c("PWID_Coast", "PWID_Nairobi"), subtype = "D - PWIDCoast&PWIDNairobi",
                       binary_trait = FALSE)) %>%
  as.data.frame() %>% t() %>% as.data.frame()
ml_summary_range.4.u_PWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_PWIDCoast_PWIDNairobi, 2, range) %>%
  as.data.frame() # range
ml_summary_comb.4.u_PWIDCoast_PWIDNairobi <- apply(ml_summary.4.u_PWIDCoast_PWIDNairobi, 2, get_subtree_means) %>% as.data.frame() %>% t() %>%
  rbind(ml_summary_range.4.u_PWIDCoast_PWIDNairobi) # add mean
# Save mean transition count (for flow diagram plotting)
riskregion.transitioncounts.u["PWIDNairobi", "PWIDCoast"] <-
  mean(as.numeric(ml_summary.4.u_PWIDCoast_PWIDNairobi$trait0to1))
riskregion.transitioncounts.u["PWIDCoast", "PWIDNairobi"] <-
  mean(as.numeric(ml_summary.4.u_PWIDCoast_PWIDNairobi$trait1to0))





# Combine into 1 table
ml_summary.4.u <- rbind(ml_summary_comb.4.u_nonPWIDCoast_nonPWIDNairobi,
                              ml_summary_comb.4.u_nonPWIDCoast_PWIDCoast) %>%
  rbind(ml_summary_comb.4.u_nonPWIDCoast_PWIDNairobi) %>%
  rbind(ml_summary_comb.4.u_nonPWIDNairobi_PWIDCoast) %>%
  rbind(ml_summary_comb.4.u_nonPWIDNairobi_PWIDNairobi) %>%
  rbind(ml_summary_comb.4.u_PWIDCoast_PWIDNairobi)

#Print fancy table:
fancify_table(ml_summary.4.u, title = "SHARP ML - uniform subsampling") %T>% print(.) %>%
  save_kable(paste0(save_path, "D/D_PWIDxregion_ASR_ml_uniform_nonPWIDCoast_PWIDCoast_summary_table_4.html"))
```




### Save Raw Result Data
```{r D.4 - save backup data - u, eval = D & run4 & save_backup}
saveRDS(transition_counts.ml.4.u, paste0(save_path, "raw_results/transition_counts.ml.D.4.u.Rmd"))
saveRDS(transition_counts.permuted.ml.4.u, paste0(save_path, "raw_results/transition_counts.permuted.ml.D.4.u.Rmd"))

saveRDS(ml_summary.4.u_nonPWIDCoast_nonPWIDNairobi, paste0(save_path, "raw_results/ml_summary.D.4.u_nonPWIDCoast_nonPWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDCoast_PWIDCoast, paste0(save_path, "raw_results/ml_summary.D.4.u_nonPWIDCoast_PWIDCoast.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDCoast_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.D.4.u_nonPWIDCoast_PWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDNairobi_PWIDCoast, paste0(save_path, "raw_results/ml_summary.D.4.u_nonPWIDNairobi_PWIDCoast.Rmd"))
saveRDS(ml_summary.4.u_nonPWIDNairobi_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.D.4.u_nonPWIDNairobi_PWIDNairobi.Rmd"))
saveRDS(ml_summary.4.u_PWIDCoast_PWIDNairobi, paste0(save_path, "raw_results/ml_summary.D.4.u_PWIDCoast_PWIDNairobi.Rmd"))
```




#### Get a p-value that combines all the resamples (instead of averaging the p-values for each resample)

```{r D.4 - p-value based on all resamples - u, eval = D & run4}


## average p -value ##

# within trait
within_p_nonPWIDCoast.u <- c()
for(i in 1:n_subsamples_D){
  withinVfrom_nonPWIDCoast.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][8,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][6,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][6,]))  +
        mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][6,])) )
  withinVfrom_nonPWIDCoast.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][8,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][6,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][6,])  +
        unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][6,]) )
  
  within_p_nonPWIDCoast.u.averaged <- append(within_p_nonPWIDCoast.u, get_p_value(withinVfrom_nonPWIDCoast.observed, withinVfrom_nonPWIDCoast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_nonPWIDNairobi.u <- c()
for(i in 1:n_subsamples_D){
  withinVfrom_nonPWIDNairobi.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][6,]))  +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][6,])) )
  withinVfrom_nonPWIDNairobi.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][6,])  +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][6,]) )
  
  within_p_nonPWIDNairobi.u.averaged <- append(within_p_nonPWIDCoast.u, get_p_value(withinVfrom_nonPWIDNairobi.observed, withinVfrom_nonPWIDNairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_PWIDCoast.u <- c()
for(i in 1:n_subsamples_D){
  withinVfrom_PWIDCoast.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][5,]))  +
        mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi[[i]][6,])) )
  withinVfrom_PWIDCoast.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast[[i]][5,])  +
        unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi[[i]][6,]) )
  
  within_p_PWIDCoast.u.averaged <- append(within_p_PWIDCoast.u, get_p_value(withinVfrom_PWIDCoast.observed, withinVfrom_PWIDCoast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

within_p_PWIDNairobi.u <- c()
for(i in 1:n_subsamples_D){
  withinVfrom_PWIDNairobi.observed <-
    mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][7,])) / 
    ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][5,])) +
        mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][5,]))  +
        mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi[[i]][5,])) )
  withinVfrom_PWIDNairobi.permuted <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][7,]) / 
    ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi[[i]][5,]) +
        unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi[[i]][5,])  +
        unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi[[i]][5,]) )
  
  within_p_PWIDNairobi.u.averaged <- append(within_p_PWIDCoast.u, get_p_value(withinVfrom_PWIDNairobi.observed, withinVfrom_PWIDNairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

withinTrait_PValues.4.u.average <- paste("Within non-PWID Coast (Average):", round(mean(within_p_nonPWIDCoast.u.averaged),3),
      "\nWithin non-PWID Nairobi (Average):", round(mean(within_p_nonPWIDNairobi.u.averaged),3),
      "\nWithin PWID Coast (Average):", round(mean(within_p_PWIDCoast.u.averaged),3),
      "\nWithin PWID Nairobi (Average):", round(mean(within_p_PWIDNairobi.u.averaged),3))
cat(withinTrait_PValues.4.u.average)





## combined p -values (combine subtrees then calculate 1 p-value) ##

# combine subtrees - observed
transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDNairobi_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.ml.4.u_PWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)

# combine subtrees - permuted
transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb <- 
  matrix(do.call(cbind,transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi), nrow = 8, byrow= FALSE)
transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb <-
  matrix(do.call(cbind, transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi),nrow = 8, byrow= FALSE)


# Get p-values
withinVfrom_nonPWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [8,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,]))  +
      mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,])) )
withinVfrom_nonPWIDCoast.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [8,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,])  +
      unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,]) )
  
  within_p_nonPWIDCoast.u.comb  <- get_p_value(withinVfrom_nonPWIDCoast.observed.comb , withinVfrom_nonPWIDCoast.permuted.comb ,
                                         tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_nonPWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,]))  +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb[6,])) )
withinVfrom_nonPWIDNairobi.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,])  +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,]) )
  
  within_p_nonPWIDNairobi.u.comb  <- get_p_value(withinVfrom_nonPWIDNairobi.observed.comb , withinVfrom_nonPWIDNairobi.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,]))  +
      mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,])) )
withinVfrom_PWIDCoast.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,])  +
      unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,]) )
  
  within_p_PWIDCoast.u.comb  <- get_p_value(withinVfrom_PWIDCoast.observed.comb , withinVfrom_PWIDCoast.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinVfrom_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [7,])) / 
  ( mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,])) +
      mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,]))  +
      mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,])) )
withinVfrom_PWIDNairobi.permuted.comb  <- unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [7,]) / 
  ( unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,]) +
      unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,])  +
      unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,]) )
  
  within_p_PWIDNairobi.u.comb  <- get_p_value(withinVfrom_PWIDNairobi.observed.comb , withinVfrom_PWIDNairobi.permuted.comb , tails = 1, H_direction = ">", scale0 = TRUE)


withinTrait_PValues.4.u.comb <- paste("Within non-PWID Coast (Combined):", round(mean(within_p_nonPWIDCoast.u.comb ),3),
      "\nWithin non-PWID Nairobi (Combined):", round(within_p_nonPWIDNairobi.u.comb, 3),
      "\nWithin PWID Coast (Combined):", round(within_p_PWIDCoast.u.comb, 3),
      "\nWithin PWID Nairobi (Combined):", round(within_p_PWIDNairobi.u.comb, 3))
cat(withinTrait_PValues.4.u.comb)







## Directional 

nonPWIDCoast_V_nonPWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,]))
nonPWIDCoast_V_nonPWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_nonPWIDNairobi.comb [6,])
  
nonPWIDCoast_V_nonPWIDNairobi.u.comb  <-get_p_value(nonPWIDCoast_V_nonPWIDNairobi.observed.comb,
                                                     nonPWIDCoast_V_nonPWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)



nonPWIDCoast_V_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,]))
nonPWIDCoast_V_PWIDCoast.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDCoast.comb [6,])
  
nonPWIDCoast_V_PWIDCoast.u.comb  <-get_p_value(nonPWIDCoast_V_PWIDCoast.observed.comb,
                                                     nonPWIDCoast_V_PWIDCoast.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDCoast_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,]))
nonPWIDCoast_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDCoast_PWIDNairobi.comb [6,])
  
nonPWIDCoast_V_PWIDNairobi.u.comb  <-get_p_value(nonPWIDCoast_V_PWIDNairobi.observed.comb,
                                                     nonPWIDCoast_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDNairobi_V_PWIDCoast.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,]))
nonPWIDNairobi_V_PWIDCoast.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDCoast.comb [6,])
  
nonPWIDNairobi_V_PWIDCoast.u.comb  <-get_p_value(nonPWIDNairobi_V_PWIDCoast.observed.comb,
                                                     nonPWIDNairobi_V_PWIDCoast.permuted.comb, tails = 2, scale0 = TRUE)


nonPWIDNairobi_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,]))
nonPWIDNairobi_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_nonPWIDNairobi_PWIDNairobi.comb [6,])
  
nonPWIDNairobi_V_PWIDNairobi.u.comb  <-get_p_value(nonPWIDNairobi_V_PWIDNairobi.observed.comb,
                                                     nonPWIDNairobi_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


PWIDCoast_V_PWIDNairobi.observed.comb  <-
  mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,])) /
  mean(unlist(transitions.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,]))
PWIDCoast_V_PWIDNairobi.permuted.comb  <-
  unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [5,]) / 
  unlist(transitions.permuted.ml.4.u_PWIDCoast_PWIDNairobi.comb [6,])
  
PWIDCoast_V_PWIDNairobi.u.comb  <-get_p_value(PWIDCoast_V_PWIDNairobi.observed.comb,
                                                     PWIDCoast_V_PWIDNairobi.permuted.comb, tails = 2, scale0 = TRUE)


directional_PValues.4.u.comb <- paste(
  "non-PWID Coast V non-PWID Nairobi (Combined):", round(nonPWIDCoast_V_nonPWIDNairobi.u.comb, 3),
  "\nnon-PWID Coast V PWID Coast (Combined):", round(nonPWIDCoast_V_PWIDCoast.u.comb, 3),
  "\nnon-PWID Coast V PWID Nairobi (Combined):", round(nonPWIDCoast_V_PWIDNairobi.u.comb, 3),
  "\nnon-PWID Nairobi V PWID Coast (Combined):", round(nonPWIDNairobi_V_PWIDCoast.u.comb, 3),
  "\nnon-PWID Nairobi V PWID Nairobi (Combined):", round(nonPWIDNairobi_V_PWIDNairobi.u.comb, 3),
  "\nPWID Coast V PWID Nairobi (Combined):", round(nonPWIDNairobi_V_PWIDNairobi.u.comb,3 )
       )
cat(directional_PValues.4.u.comb)


## Save all
PValues.4.u <- paste(withinTrait_PValues.4.u.average, "\n\n", withinTrait_PValues.4.u.comb, "\n\n",
                             directional_PValues.4.u.comb)

cat(PValues.4.u, file = paste0(save_path, "D/D_PWIDxregion_ASR_ml_uniform.4.p_value.txt"))
```


#### Illustration: different permutations
Not used in analysis: This is to show what the resampled trees (ie. random region assignments) look like
```{r D.4 - permutation illustration - u, fig.width=10, fig.height=20, eval = FALSE}
# Uniform subsampling
png(paste0(save_path, "D/D_PWIDxregion_ASR_ml_uniform_subsamp_permutation_plots_4.png"), height = 20, width = 8, units = "in", res = 1000)

layout(matrix(1:4, ncol = 1))
plots <- list()
set.seed(1)

for(i in 1:4){
  pd.4.u.resampled_example <- resample_trait(pd.4.u[[1]])
  fit.4.u.resample_example <- pml(trees.Uniform_riskregion[[1]], pd.4.u.resampled_example)
  ap.4.u.resample_example <- ancestral.pml(fit.4.u.resample_example, "ml")
  
  plotAnc(trees.Uniform_riskregion[[1]], ap.4.u.resample_example, cex = 0.4, show.tip.label = FALSE)
}

dev.off()

#Also print to screen
knitr::include_graphics(paste0(save_path, "D/D_PWIDxregion_ASR_ml_uniform_subsamp_permutation_plots_4.png"))

par(mfrow=c(1,1))
```




### Illustration: Plot transitions counts against permutations
Not doing for D subtype



## Plot flow diagrams (from region & risk combined var)
```{r D.4 - flow diagrams - u, eval = D & run4}


# Uniform subsampling

#FROM is columns, TO is rows

riskregion.transitioncounts.u <- round(riskregion.transitioncounts.u, 1)

riskregion.transitioncounts.u <- ifelse(is.na(riskregion.transitioncounts.u), 0 , riskregion.transitioncounts.u) #replace NA values with 0 - otherwise grey function won't work


# Set arrow widths as transition proportionate to pop size
transitions.colorgrad <- gray(1- (riskregion.transitioncounts.u/max(riskregion.transitioncounts.u, na.rm = TRUE))) %>% #This gives each value in the matrix as a percent of the max value (then inverses because lower values are darker) and then gets the corresponding greyscale level
  matrix(nrow = nrow(riskregion.transitioncounts.u), ncol = ncol(riskregion.transitioncounts.u), byrow = FALSE)

#Check - these should match up 
riskregion.transitioncounts.u
grid.raster(as.raster(transitions.colorgrad), width = 1, height = 1, interpolate = FALSE)


png(filename = paste0(save_path, "D/D_PWIDxregion_uniform_flow_diagram_4.png"))
  plotmat(riskregion.transitioncounts.u, pos = c(2, 2), 
          arr.width = 0.4, arr.type = "triangle", arr.col = transitions.colorgrad,
          arr.lcol = transitions.colorgrad, dtext = 0.25,
          self.cex = 0.5, self.shiftx = c(-0.05,0.05,-0.05,0.05),
          self.shifty = c(0.025,0.025,-0.025,-0.025), 
          box.lwd = 1, box.size = .05, box.type = "square",
          box.prop = .5, box.cex = .8, curve = 0.1, shadow.size = 0, relsize = 1.2,
          box.col = c("pink", "lightblue", "green", "yellow"))
dev.off()


```



### Drop objects
```{r drop D.4 vars, eval = FALSE}
if(drop_ASR == TRUE){
  suppressWarnings({rm(
    #ASR objects
     pd.4.u, fit.4.u, ap.4.u,

    #transition counts - true
     transitions.ml.4.u,
    #transition counts - permuted
     transitions.permuted.ml.4.u,
     ml_summary.4.u,
     
    #Examples for plotting - true
     fit.4.u.example, ap.4.u.example,
     #Examples for plotting - permuted
     pd.4.u.resampled_example, pd.4.u.resampled_example.phylo,
     fit.4.u.resample_example,
     ap.4.u.resample_example, ap.4.u.resample_examples.list,
     nodestates.4.u.resample_example, 
     resolved.4.u.resample_example,
    
    #plots
    transitions_plot.ml.4.u)})
}
```







































<br><br><br><br><br><br><br><br>

# Notes:  
### To do:  
  * Add SHARP-only region analysis for subtype C and D  
  * Calculate p-values combined across subtypes?  
  * Make sure all appropriate objects are dropped between runs (for tidiness)  
  * Final check  














<br><br><br><br><br><br>

# BACKUP

#### FUNCTION: Get a combined p-value combined across different resamples
Not using because I think it's fine (maybe preferable) to just average the p-value across resamples
```{r FUNCTION: p-value based on all resamples 2, eval = FALSE}
#get_p_value(mean(combine_subtrees(transitions.ml.3.u_MSM_PWID)[,"trans_1to0"] %>% unlist()), combine_subtrees(transitions.permuted.ml.3.u_MSM_PWID)[,"trans_1to0"] %>% unlist()) - EXAMPLE - to Delete




get_combined_p_value <- function(transitions, transitions.permuted, groups = "unknown", scale0 = TRUE, LeavesOnly = FALSE, output_format = "print"){
  #scale0 only matters for the directional p-value counts and it converts all 0 counts to whichever is lowest: 1 OR mean(count) - 2SD (with minimum value 0.01). This is to avoid dividing by 0 errors. However, for small trees with many 0 counts, changing all 0's to 1's is too extreme, so we use the SD. For larger trees, the mean count will be larger, so we can just call 0 counts as 1. Since we do the same thing for the true and permuted data, there should be minimal bias. If scale0 is FALSE, NA will be returned if any of the counts are 0
  #If LeavesOnly is true, the calculation is based only on the terminal (to leaf) transitions
  #output_format cant be "print" (prints the group name within group and directional p-values to the console), "within_group" (returns the within_group_value), or "directional" (returns the directional p value)
  
  transitions.comb <-combine_subtrees(transitions) 
  transitions.permuted.comb <- combine_subtrees(transitions.permuted)
    
  #Get lists (vectors?) of all leaf counts
  if(LeavesOnly == FALSE){
    within0 <- transitions.comb[,"within_0"] %>% unlist()
    within1 <- transitions.comb[,"within_1"] %>% unlist()  
    trans_1to0 <- transitions.comb[,"trans_1to0"] %>% unlist()
    trans_0to1 <- transitions.comb[,"trans_0to1"] %>% unlist()  
    
    within0.permuted <- transitions.permuted.comb[,"within_0"] %>% unlist()
    within1.permuted <- transitions.permuted.comb[,"within_1"] %>% unlist()
    trans_1to0.permuted <- transitions.permuted.comb[,"trans_1to0"] %>% unlist()
    trans_0to1.permuted <- transitions.permuted.comb[,"trans_0to1"] %>% unlist()
    
  } else {
    within0 <- transitions.comb[,"within_0_leaves"] %>% unlist()
    within1 <- transitions.comb[,"within_1_leaves"] %>% unlist()      
    trans_1to0 <- transitions.comb[,"trans_1to0_leaves"] %>% unlist()
    trans_0to1 <- transitions.comb[,"trans_0to1_leaves"] %>% unlist()
    
    within0.permuted <- transitions.permuted.comb[,"within_0_leaves"] %>% unlist()
    within1.permuted <- transitions.permuted.comb[,"within_1_leaves"] %>% unlist()   
    trans_1to0.permuted <- transitions.permuted.comb[,"trans_1to0_leaves"] %>% unlist()
    trans_0to1.permuted <- transitions.permuted.comb[,"trans_0to1_leaves"] %>% unlist()
  }
  
  
  # directional P-value, combining all subsamples
    if(scale0 == TRUE){
      replace0s <- function(count.vec){
        count.vec.0replace <- min(1, ifelse(mean(count.vec)-2*sd(count.vec)<0.01, 0.01, mean(count.vec)-2*sd(count.vec)))
        count.vec <- ifelse(count.vec == 0, count.vec.0replace, count.vec)
      }
      
      trans_1to0 <- replace0s(trans_1to0)
      trans_0to1 <- replace0s(trans_0to1)
      trans_1to0.permuted <- replace0s(trans_1to0.permuted)
      trans_0to1.permuted <- replace0s(trans_0to1.permuted)
  }

  # within-group P-value, combining all subsamples
  within_p_value <- get_p_value(observed = (within0 + within1)/(trans_1to0 + trans_0to1),
    permutations = (within0.permuted + within1.permuted)/(trans_1to0.permuted + trans_0to1.permuted) ,
    tails = 1)
  
  # between-group P-value, combining all subsamples
  directional_p_value <- get_p_value(
    observed = trans_1to0 / trans_0to1 ,
    permutations = trans_1to0.permuted / trans_0to1.permuted ,
    tails = 2
  )
  
  if(output_format == "print"){
    cat(paste0("Groups: ", groups, "\nWithin group P: ", round(within_p_value,3), "\nDirectional P: ", round(directional_p_value,3), "\n\n"))
  }
  if(output_format == "within_group"){
    return(round(within_p_value,3))
  }
  if(output_format == "directional"){
    return(round(directional_p_value,3))
  }
}
```


#### Get within-group P value (For binary traits like region, this can be pulled directly from summary table and is, therefore, not needed)
Within group p-value is a ratio of transitions within the group vs all transitions from the group. Since summary table only uses the binary comparisons, we calculate this p-value separately

```{r A1.1 - p-value based on all resamples - u, eval = FALSE}
# Uniform subsampling  ##

### Nairobi - within group
within_p_Nairobi.u.1 <- c()

for(i in 1:n_subsamples_A1){
  withinVfrom_Nairobi.observed <- mean(unlist(transitions.ml.1.u[[i]][7,])) / 
    ( mean(unlist(transitions.ml.1.u[[i]][5,])) +
        mean(unlist(transitions.ml.1.u[[i]][5,]))  +
        mean(unlist(transitions.ml.1.u[[i]][5,])) )
  withinVfrom_Nairobi.permuted <- unlist(transitions.ml.1.u[[i]][7,]) / 
    ( unlist(transitions.ml.1.u[[i]][5,]) +
        unlist(transitions.ml.1.u[[i]][5,])  +
        unlist(transitions.ml.1.u[[i]][5,]) )
  
  within_p_Nairobi.u.1 <- append(within_p_Nairobi.u.1, get_p_value(withinVfrom_Nairobi.observed, withinVfrom_Nairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}


### Coast - within group
within_p_Coast.u.1 <- c()

for(i in 1:n_subsamples_A1){
  withinVfrom_Coast.observed <- mean(unlist(transitions.ml.1.u[[i]][8,])) / 
    ( mean(unlist(transitions.ml.1.u[[i]][6,])) +
        mean(unlist(transitions.ml.1.u[[i]][6,]))  +
        mean(unlist(transitions.ml.1.u[[i]][6,])) )
  withinVfrom_Coast.permuted <- unlist(transitions.ml.1.u[[i]][8,]) / 
    ( unlist(transitions.ml.1.u[[i]][6,]) +
        unlist(transitions.ml.1.u[[i]][6,])  +
        unlist(transitions.ml.1.u[[i]][6,]) )
  
  within_p_Coast.u.1 <- append(within_p_Coast.u.1, get_p_value(withinVfrom_Coast.observed, withinVfrom_Coast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}


### Directional

#Combine summary across subtrees
transitions.ml.1.u.comb <- matrix(do.call(cbind, transitions.ml.1.u), nrow = 8, byrow= FALSE)
transitions.permuted.ml.1.u.comb <- matrix(do.call(cbind, transitions.permuted.ml.1.u), nrow = 8, byrow= FALSE)

directional.observed <- unlist(transitions.ml.1.u.comb[8,]) /unlist(transitions.ml.1.u.comb[6,])
directional.permuted <- unlist(transitions.permuted.ml.1.u.comb[8,]) / unlist(transitions.permuted.ml.1.u.comb[6,])
  
directional_p.u.1 <- get_p_value(directional.observed, directional.permuted , tails = 2, scale0 = TRUE)




### Print
p_values.u.1 <- paste("Within vs from Nairobi (averaged): ", round(mean(within_p_Nairobi.u.1), 3),
      "\nWithin vs from Coast (Averaged): ", round(mean(within_p_Coast.u.1), 3),
      "\nDirectional (Combined): ", round(directional_p.u.1, 3))
cat(p_values.u.1) #Print


### Save All ##
cat(p_values.u.1, file = paste0(save_path, "A1/A1_region_ASR_ml_uniform.1.p_value.txt"))






## Proportionate subsampling ##


### Nairobi
within_p_Nairobi.p.1 <- c()

for(i in 1:n_subsamples_A1){
  withinVfrom_Nairobi.observed <- mean(unlist(transitions.ml.1.p[[i]][7,])) / 
    ( mean(unlist(transitions.ml.1.p[[i]][5,])) +
        mean(unlist(transitions.ml.1.p[[i]][5,]))  +
        mean(unlist(transitions.ml.1.p[[i]][5,])) )
  withinVfrom_Nairobi.permuted <- unlist(transitions.ml.1.p[[i]][7,]) / 
    ( unlist(transitions.ml.1.p[[i]][5,]) +
        unlist(transitions.ml.1.p[[i]][5,])  +
        unlist(transitions.ml.1.p[[i]][5,]) )
  
  within_p_Nairobi.p.1 <- append(within_p_Nairobi.p.1, get_p_value(withinVfrom_Nairobi.observed, withinVfrom_Nairobi.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}


### Coast
within_p_Coast.p.1 <- c()

for(i in 1:n_subsamples_A1){
  withinVfrom_Coast.observed <- mean(unlist(transitions.ml.1.p[[i]][8,])) / 
    ( mean(unlist(transitions.ml.1.p[[i]][6,])) +
        mean(unlist(transitions.ml.1.p[[i]][6,]))  +
        mean(unlist(transitions.ml.1.p[[i]][6,])) )
  withinVfrom_Coast.permuted <- unlist(transitions.ml.1.p[[i]][8,]) / 
    ( unlist(transitions.ml.1.p[[i]][6,]) +
        unlist(transitions.ml.1.p[[i]][6,])  +
        unlist(transitions.ml.1.p[[i]][6,]) )
  
  within_p_Coast.p.1 <- append(within_p_Coast.p.1, get_p_value(withinVfrom_Coast.observed, withinVfrom_Coast.permuted, tails = 1, H_direction = ">", scale0 = TRUE))
}

### Print
p_values.p.1 <- paste("\nWithin vs from Nairobi (Averaged): ", round(mean(within_p_Nairobi.p.1), 3),
      "\nWithin vs from Coast (Averaged): ", round(mean(within_p_Coast.p.1), 3))
cat(p_values.p.1) #Print





## Save All ##
cat(p_values.p.1, file = paste0(save_path, "A1/A1_region_ASR_ml_proportionate.1.p_value.txt"))


```





